<!doctype html><html lang=zh dir=auto>
<head><meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<meta name=robots content="index, follow">
<title>誰說不能在 vim 裡編譯，從 :make 到 :Make | no code no pain</title>
<meta name=keywords content="vim">
<meta name=description content="前言 回想一下，上一次使用 vim 寫 code 到一個段落要編譯時，你是怎麼做的。
我看到大多數人的方式，就是將 terminal 切成兩塊，一塊寫 code，一塊編譯，若編譯有錯誤，再移動到寫 code 區塊更改。 如果使用此方法，當專案有規模時，編譯錯誤一百條，看了編譯錯誤在哪之後，再將編譯錯誤的位置，從專案裡找出來，反覆來回 100 次，直到修正完畢。 本文以 C 語言專案為例 (當然不是只有 C 語言才能這樣子幹，可看 Q&A)，聊聊強大的 vim 在這種情境下有什麼好的解決方案。 強大的 :make 基本款 此次範例就拿 neovim 來編譯好了，根據官方文件要這樣編譯 make CMAKE_BUILD_TYPE=Release，所以在我在 vim 裡這樣編 :make CMAKE_BUILD_TYPE=Release
看起來噴了一點錯誤，案了 enter 似乎之後什麼事都沒發生，回到平常。 用 :cl 指令，喔幹!不是一點錯誤，是一堆錯誤，沒列出來根本不知道。 重點來了!! 可以使用 :cn (:cnext) 跳到下一個錯誤位置，:cp (:cprevious) 跳轉到上一個錯誤位置，就不需要自己手動一個一個錯誤找出來。 看上圖，可以觀察到，每一條錯誤前面都有一個數字，如果想要跳到特定錯誤去修那就使用 :cc [number]，跳轉到第一個錯誤就用 :cc 12，跳轉到第三個錯誤就用 :cc 19。
火力展示: 總結一下指令:
 :make: 執行 makefile :cl: 列出所有錯誤 :cn: 跳到下個錯誤 :cp: 跳到上個錯誤 :cc [number]: 跳轉到特定錯誤  如虎添翼的 quickfix-window 編譯完之後，除了用 :cl 查看，另一種方式就是用 :copen，打下此指令之後，將會彈出 quickfix-window，列出的錯誤其實就是 :clist 的詳細版本， quickfix-window 只是提供了一種查找的方式。 移轉到 quickfix-window 後，移動到想要查看的錯誤，案 enter 即可跳轉到該錯誤位置，當然也能配合 :cn, :cp, :cc [number]，quickfix-window 會配合這些指令連動顯示目前位置。">
<meta name=author content="amikai">
<link rel=canonical href=https://amikai.github.io/2020/09/10/vim-make/>
<link href=/assets/css/stylesheet.min.746a86b58bb2b052b5e4df8216510494f04f81e62c08d626150c26c69ca929da.css integrity="sha256-dGqGtYuysFK15N+CFlEElPBPgeYsCNYmFQwmxpypKdo=" rel="preload stylesheet" as=style>
<link rel=icon href=https://amikai.github.io/favicon.ico>
<link rel=icon type=image/png sizes=16x16 href=https://amikai.github.io/favicon-16x16.png>
<link rel=icon type=image/png sizes=32x32 href=https://amikai.github.io/favicon-32x32.png>
<link rel=apple-touch-icon href=https://amikai.github.io/apple-touch-icon.png>
<link rel=mask-icon href=https://amikai.github.io/safari-pinned-tab.svg>
<meta name=theme-color content="#2e2e33">
<meta name=msapplication-TileColor content="#2e2e33">
<meta name=generator content="Hugo 0.86.0">
<link rel=alternate hreflang=zh href=https://amikai.github.io/2020/09/10/vim-make/>
<script type=application/javascript>var doNotTrack=!1;doNotTrack||(window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga('create','UA-172478407-1','auto'),ga('send','pageview'))</script>
<script async src=https://www.google-analytics.com/analytics.js></script>
<meta property="og:title" content="誰說不能在 vim 裡編譯，從 :make 到 :Make">
<meta property="og:description" content="前言 回想一下，上一次使用 vim 寫 code 到一個段落要編譯時，你是怎麼做的。
我看到大多數人的方式，就是將 terminal 切成兩塊，一塊寫 code，一塊編譯，若編譯有錯誤，再移動到寫 code 區塊更改。 如果使用此方法，當專案有規模時，編譯錯誤一百條，看了編譯錯誤在哪之後，再將編譯錯誤的位置，從專案裡找出來，反覆來回 100 次，直到修正完畢。 本文以 C 語言專案為例 (當然不是只有 C 語言才能這樣子幹，可看 Q&A)，聊聊強大的 vim 在這種情境下有什麼好的解決方案。 強大的 :make 基本款 此次範例就拿 neovim 來編譯好了，根據官方文件要這樣編譯 make CMAKE_BUILD_TYPE=Release，所以在我在 vim 裡這樣編 :make CMAKE_BUILD_TYPE=Release
看起來噴了一點錯誤，案了 enter 似乎之後什麼事都沒發生，回到平常。 用 :cl 指令，喔幹!不是一點錯誤，是一堆錯誤，沒列出來根本不知道。 重點來了!! 可以使用 :cn (:cnext) 跳到下一個錯誤位置，:cp (:cprevious) 跳轉到上一個錯誤位置，就不需要自己手動一個一個錯誤找出來。 看上圖，可以觀察到，每一條錯誤前面都有一個數字，如果想要跳到特定錯誤去修那就使用 :cc [number]，跳轉到第一個錯誤就用 :cc 12，跳轉到第三個錯誤就用 :cc 19。
火力展示: 總結一下指令:
 :make: 執行 makefile :cl: 列出所有錯誤 :cn: 跳到下個錯誤 :cp: 跳到上個錯誤 :cc [number]: 跳轉到特定錯誤  如虎添翼的 quickfix-window 編譯完之後，除了用 :cl 查看，另一種方式就是用 :copen，打下此指令之後，將會彈出 quickfix-window，列出的錯誤其實就是 :clist 的詳細版本， quickfix-window 只是提供了一種查找的方式。 移轉到 quickfix-window 後，移動到想要查看的錯誤，案 enter 即可跳轉到該錯誤位置，當然也能配合 :cn, :cp, :cc [number]，quickfix-window 會配合這些指令連動顯示目前位置。">
<meta property="og:type" content="article">
<meta property="og:url" content="https://amikai.github.io/2020/09/10/vim-make/"><meta property="article:section" content="posts">
<meta property="article:published_time" content="2020-09-10T00:21:31+00:00">
<meta property="article:modified_time" content="2020-09-10T00:21:31+00:00">
<meta name=twitter:card content="summary">
<meta name=twitter:title content="誰說不能在 vim 裡編譯，從 :make 到 :Make">
<meta name=twitter:description content="前言 回想一下，上一次使用 vim 寫 code 到一個段落要編譯時，你是怎麼做的。
我看到大多數人的方式，就是將 terminal 切成兩塊，一塊寫 code，一塊編譯，若編譯有錯誤，再移動到寫 code 區塊更改。 如果使用此方法，當專案有規模時，編譯錯誤一百條，看了編譯錯誤在哪之後，再將編譯錯誤的位置，從專案裡找出來，反覆來回 100 次，直到修正完畢。 本文以 C 語言專案為例 (當然不是只有 C 語言才能這樣子幹，可看 Q&A)，聊聊強大的 vim 在這種情境下有什麼好的解決方案。 強大的 :make 基本款 此次範例就拿 neovim 來編譯好了，根據官方文件要這樣編譯 make CMAKE_BUILD_TYPE=Release，所以在我在 vim 裡這樣編 :make CMAKE_BUILD_TYPE=Release
看起來噴了一點錯誤，案了 enter 似乎之後什麼事都沒發生，回到平常。 用 :cl 指令，喔幹!不是一點錯誤，是一堆錯誤，沒列出來根本不知道。 重點來了!! 可以使用 :cn (:cnext) 跳到下一個錯誤位置，:cp (:cprevious) 跳轉到上一個錯誤位置，就不需要自己手動一個一個錯誤找出來。 看上圖，可以觀察到，每一條錯誤前面都有一個數字，如果想要跳到特定錯誤去修那就使用 :cc [number]，跳轉到第一個錯誤就用 :cc 12，跳轉到第三個錯誤就用 :cc 19。
火力展示: 總結一下指令:
 :make: 執行 makefile :cl: 列出所有錯誤 :cn: 跳到下個錯誤 :cp: 跳到上個錯誤 :cc [number]: 跳轉到特定錯誤  如虎添翼的 quickfix-window 編譯完之後，除了用 :cl 查看，另一種方式就是用 :copen，打下此指令之後，將會彈出 quickfix-window，列出的錯誤其實就是 :clist 的詳細版本， quickfix-window 只是提供了一種查找的方式。 移轉到 quickfix-window 後，移動到想要查看的錯誤，案 enter 即可跳轉到該錯誤位置，當然也能配合 :cn, :cp, :cc [number]，quickfix-window 會配合這些指令連動顯示目前位置。">
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://amikai.github.io/posts/"},{"@type":"ListItem","position":3,"name":"誰說不能在 vim 裡編譯，從 :make 到 :Make","item":"https://amikai.github.io/2020/09/10/vim-make/"}]}</script>
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"誰說不能在 vim 裡編譯，從 :make 到 :Make","name":"誰說不能在 vim 裡編譯，從 :make 到 :Make","description":"前言 回想一下，上一次使用 vim 寫 code 到一個段落要編譯時，你是怎麼做的。\n我看到大多數人的方式，就是將 terminal 切成兩塊，一塊寫 code，一塊編譯，若編譯有錯誤，再移動到寫 code 區塊更改。 如果使用此方法，當專案有規模時，編譯錯誤一百條，看了編譯錯誤在哪之後，再將編譯錯誤的位置，從專案裡找出來，反覆來回 100 次，直到修正完畢。 本文以 C 語言專案為例 (當然不是只有 C 語言才能這樣子幹，可看 Q\u0026amp;A)，聊聊強大的 vim 在這種情境下有什麼好的解決方案。 強大的 :make 基本款 此次範例就拿 neovim 來編譯好了，根據官方文件要這樣編譯 make CMAKE_BUILD_TYPE=Release，所以在我在 vim 裡這樣編 :make CMAKE_BUILD_TYPE=Release\n看起來噴了一點錯誤，案了 enter 似乎之後什麼事都沒發生，回到平常。 用 :cl 指令，喔幹!不是一點錯誤，是一堆錯誤，沒列出來根本不知道。 重點來了!! 可以使用 :cn (:cnext) 跳到下一個錯誤位置，:cp (:cprevious) 跳轉到上一個錯誤位置，就不需要自己手動一個一個錯誤找出來。 看上圖，可以觀察到，每一條錯誤前面都有一個數字，如果想要跳到特定錯誤去修那就使用 :cc [number]，跳轉到第一個錯誤就用 :cc 12，跳轉到第三個錯誤就用 :cc 19。\n火力展示: 總結一下指令:\n :make: 執行 makefile :cl: 列出所有錯誤 :cn: 跳到下個錯誤 :cp: 跳到上個錯誤 :cc [number]: 跳轉到特定錯誤  如虎添翼的 quickfix-window 編譯完之後，除了用 :cl 查看，另一種方式就是用 :copen，打下此指令之後，將會彈出 quickfix-window，列出的錯誤其實就是 :clist 的詳細版本， quickfix-window 只是提供了一種查找的方式。 移轉到 quickfix-window 後，移動到想要查看的錯誤，案 enter 即可跳轉到該錯誤位置，當然也能配合 :cn, :cp, :cc [number]，quickfix-window 會配合這些指令連動顯示目前位置。","keywords":["vim"],"articleBody":"前言 回想一下，上一次使用 vim 寫 code 到一個段落要編譯時，你是怎麼做的。\n我看到大多數人的方式，就是將 terminal 切成兩塊，一塊寫 code，一塊編譯，若編譯有錯誤，再移動到寫 code 區塊更改。 如果使用此方法，當專案有規模時，編譯錯誤一百條，看了編譯錯誤在哪之後，再將編譯錯誤的位置，從專案裡找出來，反覆來回 100 次，直到修正完畢。 本文以 C 語言專案為例 (當然不是只有 C 語言才能這樣子幹，可看 Q\u0026A)，聊聊強大的 vim 在這種情境下有什麼好的解決方案。 強大的 :make 基本款 此次範例就拿 neovim 來編譯好了，根據官方文件要這樣編譯 make CMAKE_BUILD_TYPE=Release，所以在我在 vim 裡這樣編 :make CMAKE_BUILD_TYPE=Release\n看起來噴了一點錯誤，案了 enter 似乎之後什麼事都沒發生，回到平常。 用 :cl 指令，喔幹!不是一點錯誤，是一堆錯誤，沒列出來根本不知道。 重點來了!! 可以使用 :cn (:cnext) 跳到下一個錯誤位置，:cp (:cprevious) 跳轉到上一個錯誤位置，就不需要自己手動一個一個錯誤找出來。 看上圖，可以觀察到，每一條錯誤前面都有一個數字，如果想要跳到特定錯誤去修那就使用 :cc [number]，跳轉到第一個錯誤就用 :cc 12，跳轉到第三個錯誤就用 :cc 19。\n火力展示: 總結一下指令:\n :make: 執行 makefile :cl: 列出所有錯誤 :cn: 跳到下個錯誤 :cp: 跳到上個錯誤 :cc [number]: 跳轉到特定錯誤  如虎添翼的 quickfix-window 編譯完之後，除了用 :cl 查看，另一種方式就是用 :copen，打下此指令之後，將會彈出 quickfix-window，列出的錯誤其實就是 :clist 的詳細版本， quickfix-window 只是提供了一種查找的方式。 移轉到 quickfix-window 後，移動到想要查看的錯誤，案 enter 即可跳轉到該錯誤位置，當然也能配合 :cn, :cp, :cc [number]，quickfix-window 會配合這些指令連動顯示目前位置。\nNote: 詳見 :help quickfix-window\n讓你飛起來的 vim-dispatch 使用 vim 內建的 :make 指令，在編譯時其實是會 block 整個 vim 的，若專案夠大編譯很久，那段時間什麼都不能做，只能看著他編譯，vim-dispatch 完美解決了這個問題。\n安裝:\nPlug 'tpope/vim-dispatch'其實 vim-dispatch 用法很簡單，:Make 編譯，:Copen 打開 quickfix-window，當然也能配合剛剛所提到的跳轉指令使用，幾乎完美配合 vim 的使用習慣。\n當然 vim-dispatch 不只這樣而已，其他功能不在本篇範圍，詳情請見 vim-dispatch 的文件。\n火力展示，可以看到上方的視窗可以移動 cursor，下方則繼續編譯: Q \u0026 A vim 使用 :make 指令，那不是只有寫 Makefile 才能用嗎? 當然在想在其他語言使用 :make 指令，達到一樣效果就要編寫客製化的 plugin 了，當然很受歡迎的語言都有人寫好啦，通常都是包在語言 plugin 裡：\n rust.vim: 原本編譯方式是 cargo build，在 vim 裡變成 :make build 就好，以此類推可以 :make run vim-go:在 vim-go 可以使用 :GoBuild, :GoRun  結語 vim 是一個古老的編輯器，某些特色和 C 語言沾上關係，比如說 make 指令 (或許當年 C 語言獨佔天下!?)，當然 vim 不只可以使用 make 這種自動化編譯，vim 也開放了幾個 api 使得再起他語言也能達成一樣的效果 (詳見 :help makeprg)，在專案愈大時愈能顯現其效果，當年我也是碰了一點 linux kernel，才學習到這個技巧，加速了不少開發速度。\n如果有什麼相關技巧，歡迎在底下留言交流。\nReference  Re: [轉錄][問題] VIM 編譯與執行 vim help doc  ","wordCount":"187","inLanguage":"zh","datePublished":"2020-09-10T00:21:31Z","dateModified":"2020-09-10T00:21:31Z","author":{"@type":"Person","name":"amikai"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://amikai.github.io/2020/09/10/vim-make/"},"publisher":{"@type":"Organization","name":"no code no pain","logo":{"@type":"ImageObject","url":"https://amikai.github.io/favicon.ico"}}}</script>
</head>
<body id=top>
<script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script>
<noscript>
<style type=text/css>#theme-toggle,.top-link{display:none}</style>
<style>@media(prefers-color-scheme:dark){:root{--theme:#1d1e20;--entry:#2e2e33;--primary:rgba(255, 255, 255, 0.84);--secondary:rgba(255, 255, 255, 0.56);--tertiary:rgba(255, 255, 255, 0.16);--content:rgba(255, 255, 255, 0.74);--hljs-bg:#2e2e33;--code-bg:#37383e;--border:#333}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style>
</noscript>
<header class=header>
<nav class=nav>
<div class=logo>
<a href=https://amikai.github.io accesskey=h title="no code no pain (Alt + H)">no code no pain</a>
<span class=logo-switches>
<button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg>
</button>
<ul class=lang-switch><li>|</li>
<li>
<a href=https://amikai.github.io/en/ title=English aria-label=English>English</a>
</li>
</ul>
</span>
</div>
<ul id=menu onscroll=menu_on_scroll()>
<li>
<a href=https://amikai.github.io/archives title=Archive>
<span>Archive</span>
</a>
</li>
<li>
<a href=https://amikai.github.io/categories/ title=Categories>
<span>Categories</span>
</a>
</li>
<li>
<a href=https://amikai.github.io/tags/ title=Tags>
<span>Tags</span>
</a>
</li></ul>
</nav>
</header>
<main class=main>
<article class=post-single>
<header class=post-header>
<h1 class=post-title>
誰說不能在 vim 裡編譯，從 :make 到 :Make
</h1>
<div class=post-meta>
September 10, 2020&nbsp;·&nbsp;amikai
</div>
</header>
<div class=post-content>
<h1 id=前言>前言<a hidden class=anchor aria-hidden=true href=#前言>#</a></h1>
<p>回想一下，上一次使用 vim 寫 code 到一個段落要編譯時，你是怎麼做的。</p>
<p>我看到大多數人的方式，就是將 terminal 切成兩塊，一塊寫 code，一塊編譯，若編譯有錯誤，再移動到寫 code 區塊更改。
如果使用此方法，當專案有規模時，編譯錯誤一百條，看了編譯錯誤在哪之後，再將編譯錯誤的位置，從專案裡找出來，反覆來回 100 次，直到修正完畢。
本文以 C 語言專案為例 (當然不是只有 C 語言才能這樣子幹，可看 Q&A)，聊聊強大的 vim 在這種情境下有什麼好的解決方案。
<img loading=lazy src=tmux_split.png alt>
</p>
<h1 id=強大的-make>強大的 <code>:make</code><a hidden class=anchor aria-hidden=true href=#強大的-make>#</a></h1>
<h2 id=基本款>基本款<a hidden class=anchor aria-hidden=true href=#基本款>#</a></h2>
<p>此次範例就拿 neovim 來編譯好了，根據官方文件要這樣編譯 <code>make CMAKE_BUILD_TYPE=Release</code>，所以在我在 vim 裡這樣編 <code>:make CMAKE_BUILD_TYPE=Release</code></p>
<p>看起來噴了一點錯誤，案了 <code>enter</code> 似乎之後什麼事都沒發生，回到平常。
<img loading=lazy src=make_cmd.png alt>
</p>
<p>用 <code>:cl</code> 指令，喔幹!不是一點錯誤，是一堆錯誤，沒列出來根本不知道。
<img loading=lazy src=clist_cmd.png alt>
</p>
<p>重點來了!! 可以使用 <code>:cn</code> (<code>:cnext</code>) 跳到下一個錯誤位置，<code>:cp</code> (<code>:cprevious</code>) 跳轉到上一個錯誤位置，就不需要自己手動一個一個錯誤找出來。
看上圖，可以觀察到，每一條錯誤前面都有一個數字，如果想要跳到特定錯誤去修那就使用 <code>:cc [number]</code>，跳轉到第一個錯誤就用 <code>:cc 12</code>，跳轉到第三個錯誤就用 <code>:cc 19</code>。</p>
<p>火力展示:
<img loading=lazy src=clist_demo.gif alt>
</p>
<p>總結一下指令:</p>
<ul>
<li><code>:make</code>: 執行 makefile</li>
<li><code>:cl</code>: 列出所有錯誤</li>
<li><code>:cn</code>: 跳到下個錯誤</li>
<li><code>:cp</code>: 跳到上個錯誤</li>
<li><code>:cc [number]</code>: 跳轉到特定錯誤</li>
</ul>
<h2 id=如虎添翼的-quickfix-window>如虎添翼的 quickfix-window<a hidden class=anchor aria-hidden=true href=#如虎添翼的-quickfix-window>#</a></h2>
<p>編譯完之後，除了用 <code>:cl</code> 查看，另一種方式就是用 <code>:copen</code>，打下此指令之後，將會彈出 quickfix-window，列出的錯誤其實就是 <code>:clist</code> 的詳細版本， quickfix-window 只是提供了一種查找的方式。
<img loading=lazy src=copen_cmd.png alt>
移轉到 quickfix-window 後，移動到想要查看的錯誤，案 <code>enter</code> 即可跳轉到該錯誤位置，當然也能配合 <code>:cn</code>, <code>:cp</code>, <code>:cc [number]</code>，quickfix-window 會配合這些指令連動顯示目前位置。</p>
<p>Note: 詳見 <code>:help quickfix-window</code></p>
<h1 id=讓你飛起來的-vim-dispatch>讓你飛起來的 vim-dispatch<a hidden class=anchor aria-hidden=true href=#讓你飛起來的-vim-dispatch>#</a></h1>
<p>使用 vim 內建的 <code>:make</code> 指令，在編譯時其實是會 block 整個 vim 的，若專案夠大編譯很久，那段時間什麼都不能做，只能看著他編譯，vim-dispatch 完美解決了這個問題。</p>
<p>安裝:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-vim data-lang=vim><span style=color:#a6e22e>Plug</span> <span style=color:#e6db74>&#39;tpope/vim-dispatch&#39;</span><span style=color:#960050;background-color:#1e0010>
</span></code></pre></div><p>其實 vim-dispatch 用法很簡單，<code>:Make</code> 編譯，<code>:Copen</code> 打開 quickfix-window，當然也能配合剛剛所提到的跳轉指令使用，幾乎完美配合 vim 的使用習慣。</p>
<p>當然 vim-dispatch 不只這樣而已，其他功能不在本篇範圍，詳情請見 vim-dispatch 的文件。</p>
<p>火力展示，可以看到上方的視窗可以移動 cursor，下方則繼續編譯:
<img loading=lazy src=Make_demo.gif alt>
</p>
<h1 id=q--a>Q & A<a hidden class=anchor aria-hidden=true href=#q--a>#</a></h1>
<h2 id=vim-使用-make-指令那不是只有寫-makefile-才能用嗎>vim 使用 <code>:make</code> 指令，那不是只有寫 Makefile 才能用嗎?<a hidden class=anchor aria-hidden=true href=#vim-使用-make-指令那不是只有寫-makefile-才能用嗎>#</a></h2>
<p>當然在想在其他語言使用 <code>:make</code> 指令，達到一樣效果就要編寫客製化的 plugin 了，當然很受歡迎的語言都有人寫好啦，通常都是包在語言 plugin 裡：</p>
<ul>
<li><a href=https://github.com/rust-lang/rust.vim>rust.vim</a>: 原本編譯方式是 <code>cargo build</code>，在 vim 裡變成 <code>:make build</code> 就好，以此類推可以 <code>:make run</code></li>
<li><a href=https://github.com/fatih/vim-go>vim-go</a>:在 vim-go 可以使用 <code>:GoBuild</code>, <code>:GoRun</code></li>
</ul>
<h1 id=結語>結語<a hidden class=anchor aria-hidden=true href=#結語>#</a></h1>
<p>vim 是一個古老的編輯器，某些特色和 C 語言沾上關係，比如說 make 指令 (或許當年 C 語言獨佔天下!?)，當然 vim 不只可以使用 make 這種自動化編譯，vim 也開放了幾個 api 使得再起他語言也能達成一樣的效果 (詳見 <code>:help makeprg</code>)，在專案愈大時愈能顯現其效果，當年我也是碰了一點 linux kernel，才學習到這個技巧，加速了不少開發速度。</p>
<p>如果有什麼相關技巧，歡迎在底下留言交流。</p>
<h1 id=reference>Reference<a hidden class=anchor aria-hidden=true href=#reference>#</a></h1>
<ul>
<li><a href=https://www.ptt.cc/bbs/Editor/M.1285722960.A.BF5.html>Re: [轉錄][問題] VIM 編譯與執行</a></li>
<li>vim help doc</li>
</ul>
</div>
<footer class=post-footer>
<ul class=post-tags>
<li><a href=https://amikai.github.io/tags/vim/>vim</a></li>
</ul>
</footer>
<div id=disqus_thread></div>
<script type=application/javascript>var disqus_config=function(){};(function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById('disqus_thread').innerHTML='Disqus comments not available by default when the website is previewed locally.';return}var b=document,a=b.createElement('script');a.async=!0,a.src='//amikai-github-io.disqus.com/embed.js',a.setAttribute('data-timestamp',+new Date),(b.head||b.body).appendChild(a)})()</script>
<noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript>
<a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a>
</article>
</main><footer class=footer>
<span>&copy; 2021 <a href=https://amikai.github.io>no code no pain</a></span>
<span>&#183;</span>
<span>Powered by <a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a></span>
<span>&#183;</span>
<span>Theme <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span>
</footer>
<a href=#top aria-label="go to top" title="Go to Top (Alt + G)">
<button class=top-link id=top-link type=button accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</button>
</a>
<script defer src=/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5+kdJvBz5iKbt6B5PJI=" onload=hljs.initHighlightingOnLoad()></script>
<script>window.onload=function(){localStorage.getItem("menu-scroll-position")&&(document.getElementById('menu').scrollLeft=localStorage.getItem("menu-scroll-position"))};function menu_on_scroll(){localStorage.setItem("menu-scroll-position",document.getElementById('menu').scrollLeft)}document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script>
<script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script>
<script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script>
</body>
</html>