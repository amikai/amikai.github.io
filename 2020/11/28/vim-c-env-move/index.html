<!doctype html><html lang=zh dir=auto>
<head><meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<meta name=robots content="index, follow">
<title>在 (neo)vim 裡 C 語言程式碼導覽技巧 | no code no pain</title>
<meta name=keywords content="vim,neovim,c">
<meta name=description content="現代的專案開發，很少在從無到有打造，大部分都是基於現有的程式之上繼續開發或維護，進入專案之後，通常第一件事就是大量閱讀程式碼理清專案的整個脈絡，才開始著手寫 code，所以好的程式碼導覽技巧將會帶你上天堂。
我將大部分的程式碼導覽情境大致拆成了三種情況：
 基本的跳轉：  #if #endif 中間的程式碼太長，想要跳轉到成對的 #if #endif cursor 在 {&mldr;} block 裡， 這個 block 又臭又長，想快速跳轉 block 的開頭和結尾 註解長篇大論，想快速跳到註解的開頭或結尾   尋找專案下檔案 (可透過設定 path option 解決)  跳轉到標頭檔 跳轉到指定檔案   使用 source code tagging system 快速挑轉到 function 定義及特定 symbol 等等： 專案相當大的時候，source code tagging system 相當好用，可以快速找到定位，也不會花掉太多的資源，比起 LSP 的跳轉定義，是較輕量的選擇。  本篇依據上述三種情境，一一講述。
常用跳轉操作   %
 跳到成對的括號 如果註解是 /*...*/，跳到成對的註解符號 在成對的 #if, #ifdef, #else, #elif, #endif 之中跳轉，這相當重要，如果 code 很長, if else macro 又是巢狀的，這招可以讓你少迷路好幾次    [{ ]}">
<meta name=author content="amikai">
<link rel=canonical href=https://amikai.github.io/2020/11/28/vim-c-env-move/>
<link href=/assets/css/stylesheet.min.746a86b58bb2b052b5e4df8216510494f04f81e62c08d626150c26c69ca929da.css integrity="sha256-dGqGtYuysFK15N+CFlEElPBPgeYsCNYmFQwmxpypKdo=" rel="preload stylesheet" as=style>
<link rel=icon href=https://amikai.github.io/favicon.ico>
<link rel=icon type=image/png sizes=16x16 href=https://amikai.github.io/favicon-16x16.png>
<link rel=icon type=image/png sizes=32x32 href=https://amikai.github.io/favicon-32x32.png>
<link rel=apple-touch-icon href=https://amikai.github.io/apple-touch-icon.png>
<link rel=mask-icon href=https://amikai.github.io/safari-pinned-tab.svg>
<meta name=theme-color content="#2e2e33">
<meta name=msapplication-TileColor content="#2e2e33">
<meta name=generator content="Hugo 0.86.0">
<link rel=alternate hreflang=zh href=https://amikai.github.io/2020/11/28/vim-c-env-move/>
<script type=application/javascript>var doNotTrack=!1;doNotTrack||(window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga('create','UA-172478407-1','auto'),ga('send','pageview'))</script>
<script async src=https://www.google-analytics.com/analytics.js></script>
<meta property="og:title" content="在 (neo)vim 裡 C 語言程式碼導覽技巧">
<meta property="og:description" content="現代的專案開發，很少在從無到有打造，大部分都是基於現有的程式之上繼續開發或維護，進入專案之後，通常第一件事就是大量閱讀程式碼理清專案的整個脈絡，才開始著手寫 code，所以好的程式碼導覽技巧將會帶你上天堂。
我將大部分的程式碼導覽情境大致拆成了三種情況：
 基本的跳轉：  #if #endif 中間的程式碼太長，想要跳轉到成對的 #if #endif cursor 在 {&mldr;} block 裡， 這個 block 又臭又長，想快速跳轉 block 的開頭和結尾 註解長篇大論，想快速跳到註解的開頭或結尾   尋找專案下檔案 (可透過設定 path option 解決)  跳轉到標頭檔 跳轉到指定檔案   使用 source code tagging system 快速挑轉到 function 定義及特定 symbol 等等： 專案相當大的時候，source code tagging system 相當好用，可以快速找到定位，也不會花掉太多的資源，比起 LSP 的跳轉定義，是較輕量的選擇。  本篇依據上述三種情境，一一講述。
常用跳轉操作   %
 跳到成對的括號 如果註解是 /*...*/，跳到成對的註解符號 在成對的 #if, #ifdef, #else, #elif, #endif 之中跳轉，這相當重要，如果 code 很長, if else macro 又是巢狀的，這招可以讓你少迷路好幾次    [{ ]}">
<meta property="og:type" content="article">
<meta property="og:url" content="https://amikai.github.io/2020/11/28/vim-c-env-move/"><meta property="article:section" content="posts">
<meta property="article:published_time" content="2020-11-28T21:50:57+00:00">
<meta property="article:modified_time" content="2020-11-28T21:50:57+00:00">
<meta name=twitter:card content="summary">
<meta name=twitter:title content="在 (neo)vim 裡 C 語言程式碼導覽技巧">
<meta name=twitter:description content="現代的專案開發，很少在從無到有打造，大部分都是基於現有的程式之上繼續開發或維護，進入專案之後，通常第一件事就是大量閱讀程式碼理清專案的整個脈絡，才開始著手寫 code，所以好的程式碼導覽技巧將會帶你上天堂。
我將大部分的程式碼導覽情境大致拆成了三種情況：
 基本的跳轉：  #if #endif 中間的程式碼太長，想要跳轉到成對的 #if #endif cursor 在 {&mldr;} block 裡， 這個 block 又臭又長，想快速跳轉 block 的開頭和結尾 註解長篇大論，想快速跳到註解的開頭或結尾   尋找專案下檔案 (可透過設定 path option 解決)  跳轉到標頭檔 跳轉到指定檔案   使用 source code tagging system 快速挑轉到 function 定義及特定 symbol 等等： 專案相當大的時候，source code tagging system 相當好用，可以快速找到定位，也不會花掉太多的資源，比起 LSP 的跳轉定義，是較輕量的選擇。  本篇依據上述三種情境，一一講述。
常用跳轉操作   %
 跳到成對的括號 如果註解是 /*...*/，跳到成對的註解符號 在成對的 #if, #ifdef, #else, #elif, #endif 之中跳轉，這相當重要，如果 code 很長, if else macro 又是巢狀的，這招可以讓你少迷路好幾次    [{ ]}">
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://amikai.github.io/posts/"},{"@type":"ListItem","position":2,"name":"在 (neo)vim 裡 C 語言程式碼導覽技巧","item":"https://amikai.github.io/2020/11/28/vim-c-env-move/"}]}</script>
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"在 (neo)vim 裡 C 語言程式碼導覽技巧","name":"在 (neo)vim 裡 C 語言程式碼導覽技巧","description":"現代的專案開發，很少在從無到有打造，大部分都是基於現有的程式之上繼續開發或維護，進入專案之後，通常第一件事就是大量閱讀程式碼理清專案的整個脈絡，才開始著手寫 code，所以好的程式碼導覽技巧將會帶你上天堂。\n我將大部分的程式碼導覽情境大致拆成了三種情況：\n 基本的跳轉：  #if #endif 中間的程式碼太長，想要跳轉到成對的 #if #endif cursor 在 {\u0026hellip;} block 裡， 這個 block 又臭又長，想快速跳轉 block 的開頭和結尾 註解長篇大論，想快速跳到註解的開頭或結尾   尋找專案下檔案 (可透過設定 path option 解決)  跳轉到標頭檔 跳轉到指定檔案   使用 source code tagging system 快速挑轉到 function 定義及特定 symbol 等等： 專案相當大的時候，source code tagging system 相當好用，可以快速找到定位，也不會花掉太多的資源，比起 LSP 的跳轉定義，是較輕量的選擇。  本篇依據上述三種情境，一一講述。\n常用跳轉操作   %\n 跳到成對的括號 如果註解是 /*...*/，跳到成對的註解符號 在成對的 #if, #ifdef, #else, #elif, #endif 之中跳轉，這相當重要，如果 code 很長, if else macro 又是巢狀的，這招可以讓你少迷路好幾次    [{ ]}","keywords":["vim","neovim","c"],"articleBody":"現代的專案開發，很少在從無到有打造，大部分都是基於現有的程式之上繼續開發或維護，進入專案之後，通常第一件事就是大量閱讀程式碼理清專案的整個脈絡，才開始著手寫 code，所以好的程式碼導覽技巧將會帶你上天堂。\n我將大部分的程式碼導覽情境大致拆成了三種情況：\n 基本的跳轉：  #if #endif 中間的程式碼太長，想要跳轉到成對的 #if #endif cursor 在 {…} block 裡， 這個 block 又臭又長，想快速跳轉 block 的開頭和結尾 註解長篇大論，想快速跳到註解的開頭或結尾   尋找專案下檔案 (可透過設定 path option 解決)  跳轉到標頭檔 跳轉到指定檔案   使用 source code tagging system 快速挑轉到 function 定義及特定 symbol 等等： 專案相當大的時候，source code tagging system 相當好用，可以快速找到定位，也不會花掉太多的資源，比起 LSP 的跳轉定義，是較輕量的選擇。  本篇依據上述三種情境，一一講述。\n常用跳轉操作   %\n 跳到成對的括號 如果註解是 /*...*/，跳到成對的註解符號 在成對的 #if, #ifdef, #else, #elif, #endif 之中跳轉，這相當重要，如果 code 很長, if else macro 又是巢狀的，這招可以讓你少迷路好幾次    [{ ]}\n [{：若 cursor 在 {…} 區塊中，跳到此區塊的 { ]}：若 cursor 在 {…} 區塊中，跳到此區塊的 }    [* ]*\n [*：找到上一個 /* ]*：找到下一個 */    [# ]# 用法和 [{ ]} 類似，但是針對的是 # 在 line2 區塊 [{ 跳到 line1, ]} 跳到 line3 在 line4 區塊 [{ 跳到 line3, ]} 跳到 line5 在 line6 區塊 [{ 跳到 line5, ]} 跳到 line7\n#ifdef TEST // line2 #elif TEST2 // line4 #else // line6 #endif 若 cursor 在 #else…#endif 區塊中，跳到 #else\n  透過 path 設定，快速查找相關檔案 看看以下圖片，將 cursor 移動到程式碼標頭檔的位置 (stdio.h)，按下 gf，bang! 你跳到 stdio.h 標頭檔了 再來看看 :find 指令，我想找出 stdlib.h 標頭檔，使用 :find stdlib.h, 就跳到 stdlib.h 啦\n我們來看看 vim 到底怎麼實現這個魔法的： 其實 vim 是藉由 path 這個 option 去搜尋的 (詳見 :help 'path')，path 這個值由許多路徑組成並由逗號隔開，在 nix 系統裡 vim 對 path 預設的值是\n.,/usr/include,,可以看到三個值：\n .： 當前檔案所在的目錄 /usr/include： 很顯然找到 gf 找到的 stdio.h 和 :find 找到的 stdlib.h 是由這個目錄找出來的 empty string：工作目錄 (current work directory, 通常是 vim 開啟的位置，如果你沒用 :cd 的話)  所以可以把自己常用的標頭檔所在目錄加入 path ！ 舉個例子 /usr/local/include 也是很常放標頭檔的路徑，所以我把它加入到 path\n:set path+=/usr/local/include註: . 和 empty string 的差別請看：is-vims-default-path-option-redundant\n** 算是一個蠻好用的值，它會對路徑做 recursive 的解析，你可能會使用到它，詳細的規則可以看 :help starstar\nSource code tagging system 和 vim 2020 年 Linux kernel 原始碼規模已經達到 2780 萬行，規模如此之龐大，Linux 的程式開發人員到底是怎麼開發的，隨便想找一個 function 定義都相當吃力，總不能用 grep 慢慢去找吧!這時候 source code tagging system 就派上用場了，它可以對專案所有的 symbol 產生索引檔，需要查找目標時就藉由這些索引檔快速查找位置。概念其實就是字典的索引，字典這麼大一本不會有人從頭掃到尾，都是直接翻到字典最後面的索引快速找到目標。\n這些 source code tagging system，通常會產生索引檔並且提供一個介面，讓編輯器使用它們快速在程式碼內定位。\n接下來將逐一介紹 cscope, gtags, ctags 等等三個 source code tagging system 在 vim 裡的基本使用方式。\nCscope Cscope 簡介 cscope 官網聲稱可以做到以下事情：\n 查詢所有使用到這個 symbol 的地方 查詢全域變數 查詢 function 在哪被呼叫 查詢這個 function 呼叫了誰 使用字串查詢找到目標 使用 egrep pattern 尋找目標 快速尋找專案下檔案 查看哪個檔案 include 當前檔案  cscope 指令常用選項\n b：只產生索引檔案，不進入互動查詢介面 q：產生 cscope.in.out 和 cscope.po.out文件，加快 cscope 的索引速度 k：產生索引檔案时，不搜尋 /usr/include R：遞迴搜尋子目錄  Cscope 和 vim 在專案目錄產生索引檔案:\n$ cscope -bkqR 會產生三個檔案 cscope.in.out cscope.out cscope.po.out\n進入 vim 之後可以透過 cs 查看 cscope 在 vim 裡的使用方式 讓 vim 知道 cscope 的路徑\n:set cscopeprg=/path/to/cscope指定 cscope 索引檔案，讓 vim 知道要用哪個索引檔案查詢：\n:cs add cscope.out接下來就可以使用以下方式查詢 (xxx 為想搜尋的目標):\n :cs find a xxx 查尋 xxx 被賦值的地方 :cs find c xxx 查尋所有呼叫 xxx function 的地方 :cs find d xxx 查尋 xxx function 呼叫的所有函數 :cs find e xxx 使用 egrep pattern 查詢 :cs find f xxx 找出 xxx 檔案在哪裡 :cs find g xxx 查尋 xxx 所定義的地方 (通常最常用的是這個) :cs find i xxx 查尋所有 inlcude xxx 檔案的地方 :cs find s xxx 查尋所有 xxx symbol 出現的地方 :cs find t xxx 查詢 xxx 字串出現的地方，其實搜尋效果就類似 grep  記得查詢完的結果可以用 :cw, :copen 在 quickfix window 列出：\nGNU GLOBAL (gtags) 由 GNU GLOBAL 由 GNU 所開發的 soure code tagging system，本身支持四種語言，透過 Pygments 和 Universal Ctags 的 parser 可以支持其他 25 種語言，支援 incremental update，原始碼更動後，只會對改變的地方索引，不會重新索引，這對龐大的專案有很大的幫助。另外 gtags 提供了 cscope 相容的互動介面，叫做 gtags-cscope，讓你用起來像 cscope，但背後其實是 gtags 的索引檔案。\n在專案目錄產生索引檔案：\n$ gtags 讓 vim 知道 gtags-cscope 路徑：\n:set cscopeprg=/path/to/gtsgs-cscope指定 gtags 索引檔案，讓 vim 知道要用哪個索引檔案查詢：\n:cs add GTAGS借下來就可以用和 cscope 一樣的方式查詢，除了 :cs find d，其他皆支援\nCtags Ctags 簡介 最早的 Ctag 在 BSD 上實現，版本變革的歷史脈絡我不是相當清楚，查不太到資料。 現在普及的版本是 Exuberant Ctags，一開始和 vim 是一包軟體，一起發布，但在 vim6 之後獨立成兩個專案，從這裏可看出它一定和 vim 兼容良好，但此版本在 2009 年之後已不再維護。建議使用Exuberant Ctags 所 fork 的版本 Universal Ctags，目前還在維護和開發當中。\nCtags 和 vim 在專案下生成索引檔案，可以看到目錄裡有 tags 檔案\n$ ctags -R * 指定 tags 索引檔案，讓 vim 知道要用哪個索引檔案查詢：\n:set tags=tags再來就可以使用:\n Ctrl + ]: 跳到定義，如果有多個匹配則會跳到第一個 Ctrl + T: 跳回原本的地方  每次用 ctrl + ] 跳轉到定義，vim 就會把這位置推到 tag stack 裡，每次 ctrl + T 跳回原來的地方，vim 就會從 tag stack 裡 pop 位置出來，我們可以使用 :tags 看到 tag stack 裡的內容。\nReference   https://dev.to/iggredible/how-to-use-tags-in-vim-to-jump-to-definitions-quickly-2g28\n  http://praton.me/2020/04/11/Exploring-kernel-code-with-vim.html\n  :help usr_29.txt\n  :help usr_30.txt\n  :help tagsrch.txt\n  ","wordCount":"547","inLanguage":"zh","datePublished":"2020-11-28T21:50:57Z","dateModified":"2020-11-28T21:50:57Z","author":{"@type":"Person","name":"amikai"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://amikai.github.io/2020/11/28/vim-c-env-move/"},"publisher":{"@type":"Organization","name":"no code no pain","logo":{"@type":"ImageObject","url":"https://amikai.github.io/favicon.ico"}}}</script>
</head>
<body id=top>
<script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script>
<noscript>
<style type=text/css>#theme-toggle,.top-link{display:none}</style>
<style>@media(prefers-color-scheme:dark){:root{--theme:#1d1e20;--entry:#2e2e33;--primary:rgba(255, 255, 255, 0.84);--secondary:rgba(255, 255, 255, 0.56);--tertiary:rgba(255, 255, 255, 0.16);--content:rgba(255, 255, 255, 0.74);--hljs-bg:#2e2e33;--code-bg:#37383e;--border:#333}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style>
</noscript>
<header class=header>
<nav class=nav>
<div class=logo>
<a href=https://amikai.github.io/ accesskey=h title="no code no pain (Alt + H)">no code no pain</a>
<span class=logo-switches>
<button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg>
</button>
<ul class=lang-switch><li>|</li>
<li>
<a href=https://amikai.github.io/en/ title=English aria-label=English>English</a>
</li>
</ul>
</span>
</div>
<ul id=menu onscroll=menu_on_scroll()>
<li>
<a href=https://amikai.github.io/archives title=Archive>
<span>Archive</span>
</a>
</li>
<li>
<a href=https://amikai.github.io/categories/ title=Categories>
<span>Categories</span>
</a>
</li>
<li>
<a href=https://amikai.github.io/tags/ title=Tags>
<span>Tags</span>
</a>
</li></ul>
</nav>
</header>
<main class=main>
<article class=post-single>
<header class=post-header>
<h1 class=post-title>
在 (neo)vim 裡 C 語言程式碼導覽技巧
</h1>
<div class=post-meta>
November 28, 2020&nbsp;·&nbsp;amikai
</div>
</header>
<div class=post-content>
<p>現代的專案開發，很少在從無到有打造，大部分都是基於現有的程式之上繼續開發或維護，進入專案之後，通常第一件事就是大量閱讀程式碼理清專案的整個脈絡，才開始著手寫 code，所以好的程式碼導覽技巧將會帶你上天堂。</p>
<p>我將大部分的程式碼導覽情境大致拆成了三種情況：</p>
<ul>
<li>基本的跳轉：
<ul>
<li><code>#if</code> <code>#endif</code> 中間的程式碼太長，想要跳轉到成對的 <code>#if</code> <code>#endif</code></li>
<li>cursor 在 {&mldr;} block 裡， 這個 block 又臭又長，想快速跳轉 block 的開頭和結尾</li>
<li>註解長篇大論，想快速跳到註解的開頭或結尾</li>
</ul>
</li>
<li>尋找專案下檔案 (可透過設定 path option 解決)
<ul>
<li>跳轉到標頭檔</li>
<li>跳轉到指定檔案</li>
</ul>
</li>
<li>使用 source code tagging system 快速挑轉到 function 定義及特定 symbol 等等：
專案相當大的時候，source code tagging system 相當好用，可以快速找到定位，也不會花掉太多的資源，比起 LSP 的跳轉定義，是較輕量的選擇。</li>
</ul>
<p>本篇依據上述三種情境，一一講述。</p>
<h1 id=常用跳轉操作>常用跳轉操作<a hidden class=anchor aria-hidden=true href=#常用跳轉操作>#</a></h1>
<ul>
<li>
<p><code>%</code></p>
<ul>
<li>跳到成對的括號</li>
<li>如果註解是 <code>/*...*/</code>，跳到成對的註解符號</li>
<li>在成對的 <code>#if</code>, <code>#ifdef</code>, <code>#else</code>, <code>#elif</code>, <code>#endif</code> 之中跳轉，這相當重要，如果 code 很長, if else macro 又是巢狀的，這招可以讓你少迷路好幾次</li>
</ul>
</li>
<li>
<p><code>[{</code> <code>]}</code></p>
<ul>
<li><code>[{</code>：若 cursor 在 {&mldr;} 區塊中，跳到此區塊的 {</li>
<li><code>]}</code>：若 cursor 在 {&mldr;} 區塊中，跳到此區塊的 }</li>
</ul>
</li>
<li>
<p><code>[*</code> <code>]*</code></p>
<ul>
<li><code>[*</code>：找到上一個 /*</li>
<li><code>]*</code>：找到下一個 */</li>
</ul>
</li>
<li>
<p><code>[#</code> <code>]#</code>
用法和 <code>[{</code> <code>]}</code> 類似，但是針對的是 <code>#</code>
在 line2 區塊 <code>[{</code> 跳到 line1, <code>]}</code> 跳到 line3
在 line4 區塊 <code>[{</code> 跳到 line3, <code>]}</code> 跳到 line5
在 line6 區塊 <code>[{</code> 跳到 line5, <code>]}</code> 跳到 line7</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#75715e>#ifdef TEST
</span><span style=color:#75715e></span><span style=color:#75715e>// line2
</span><span style=color:#75715e></span><span style=color:#75715e>#elif TEST2
</span><span style=color:#75715e></span><span style=color:#75715e>// line4
</span><span style=color:#75715e></span><span style=color:#75715e>#else
</span><span style=color:#75715e></span><span style=color:#75715e>// line6
</span><span style=color:#75715e></span><span style=color:#75715e>#endif
</span></code></pre></div><p>若 cursor 在 #else&mldr;#endif 區塊中，跳到 #else</p>
</li>
</ul>
<h1 id=透過-path-設定快速查找相關檔案>透過 path 設定，快速查找相關檔案<a hidden class=anchor aria-hidden=true href=#透過-path-設定快速查找相關檔案>#</a></h1>
<p>看看以下圖片，將 cursor 移動到程式碼標頭檔的位置 (stdio.h)，按下 <code>gf</code>，bang! 你跳到 stdio.h 標頭檔了
<img loading=lazy src=vim_gf.gif alt>
</p>
<p>再來看看 <code>:find</code> 指令，我想找出 stdlib.h 標頭檔，使用 <code>:find stdlib.h</code>, 就跳到 stdlib.h 啦</p>
<p>我們來看看 vim 到底怎麼實現這個魔法的：
其實 vim 是藉由 <code>path</code> 這個 option 去搜尋的 (詳見 <code>:help 'path'</code>)，path 這個值由許多路徑組成並由逗號隔開，在 nix 系統裡 vim 對 path 預設的值是</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-vim data-lang=vim>.,<span style=color:#e6db74>/usr/</span><span style=color:#a6e22e>include</span>,,<span style=color:#960050;background-color:#1e0010>
</span></code></pre></div><p>可以看到三個值：</p>
<ul>
<li><code>.</code>： 當前檔案所在的目錄</li>
<li><code>/usr/include</code>： 很顯然找到 <code>gf</code> 找到的 stdio.h 和 <code>:find</code> 找到的 stdlib.h 是由這個目錄找出來的</li>
<li>empty string：工作目錄 (current work directory, 通常是 vim 開啟的位置，如果你沒用 <code>:cd</code> 的話)</li>
</ul>
<p>所以可以把自己常用的標頭檔所在目錄加入 path ！ 舉個例子 <code>/usr/local/include</code> 也是很常放標頭檔的路徑，所以我把它加入到 path</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-vim data-lang=vim>:<span style=color:#a6e22e>set</span> <span style=color:#a6e22e>path</span>+=<span style=color:#e6db74>/usr/</span><span style=color:#a6e22e>local</span>/<span style=color:#a6e22e>include</span><span style=color:#960050;background-color:#1e0010>
</span></code></pre></div><p>註: <code>.</code> 和 empty string 的差別請看：<a href=https://vi.stackexchange.com/questions/5998/is-vims-default-path-option-redundant>is-vims-default-path-option-redundant</a></p>
<p><code>**</code> 算是一個蠻好用的值，它會對路徑做 recursive 的解析，你可能會使用到它，詳細的規則可以看 <code>:help starstar</code></p>
<h1 id=source-code-tagging-system-和-vim>Source code tagging system 和 vim<a hidden class=anchor aria-hidden=true href=#source-code-tagging-system-和-vim>#</a></h1>
<p>2020 年 Linux kernel 原始碼規模已經達到 2780 萬行，規模如此之龐大，Linux 的程式開發人員到底是怎麼開發的，隨便想找一個 function 定義都相當吃力，總不能用 grep 慢慢去找吧!這時候 source code tagging system 就派上用場了，它可以對專案所有的 symbol 產生索引檔，需要查找目標時就藉由這些索引檔快速查找位置。概念其實就是字典的索引，字典這麼大一本不會有人從頭掃到尾，都是直接翻到字典最後面的索引快速找到目標。</p>
<p>這些 source code tagging system，通常會產生索引檔並且提供一個介面，讓編輯器使用它們快速在程式碼內定位。</p>
<p>接下來將逐一介紹 cscope, gtags, ctags 等等三個 source code tagging system 在 vim 裡的基本使用方式。</p>
<h1 id=cscope>Cscope<a hidden class=anchor aria-hidden=true href=#cscope>#</a></h1>
<h2 id=cscope-簡介>Cscope 簡介<a hidden class=anchor aria-hidden=true href=#cscope-簡介>#</a></h2>
<p>cscope 官網聲稱可以做到以下事情：</p>
<ul>
<li>查詢所有使用到這個 symbol 的地方</li>
<li>查詢全域變數</li>
<li>查詢 function 在哪被呼叫</li>
<li>查詢這個 function 呼叫了誰</li>
<li>使用字串查詢找到目標</li>
<li>使用 egrep pattern 尋找目標</li>
<li>快速尋找專案下檔案</li>
<li>查看哪個檔案 include 當前檔案</li>
</ul>
<p>cscope 指令常用選項</p>
<ul>
<li>b：只產生索引檔案，不進入互動查詢介面</li>
<li>q：產生 cscope.in.out 和 cscope.po.out文件，加快 cscope 的索引速度</li>
<li>k：產生索引檔案时，不搜尋 /usr/include</li>
<li>R：遞迴搜尋子目錄</li>
</ul>
<h2 id=cscope-和-vim>Cscope 和 vim<a hidden class=anchor aria-hidden=true href=#cscope-和-vim>#</a></h2>
<p>在專案目錄產生索引檔案:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>$ cscope -bkqR
</code></pre></div><p>會產生三個檔案 <code>cscope.in.out</code> <code>cscope.out</code> <code>cscope.po.out</code></p>
<p>進入 vim 之後可以透過 <code>cs</code> 查看 cscope 在 vim 裡的使用方式
<img loading=lazy src=vim_cscope.png alt>
</p>
<p>讓 vim 知道 cscope 的路徑</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-vim data-lang=vim>:<span style=color:#a6e22e>set</span> <span style=color:#a6e22e>cscopeprg</span>=<span style=color:#e6db74>/path/</span><span style=color:#a6e22e>to</span>/<span style=color:#a6e22e>cscope</span><span style=color:#960050;background-color:#1e0010>
</span></code></pre></div><p>指定 cscope 索引檔案，讓 vim 知道要用哪個索引檔案查詢：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-vim data-lang=vim>:<span style=color:#a6e22e>cs</span> <span style=color:#a6e22e>add</span> <span style=color:#a6e22e>cscope</span>.<span style=color:#a6e22e>out</span><span style=color:#960050;background-color:#1e0010>
</span></code></pre></div><p>接下來就可以使用以下方式查詢 (xxx 為想搜尋的目標):</p>
<ul>
<li><code>:cs find a xxx</code> 查尋 xxx 被賦值的地方</li>
<li><code>:cs find c xxx</code> 查尋所有呼叫 xxx function 的地方</li>
<li><code>:cs find d xxx</code> 查尋 xxx function 呼叫的所有函數</li>
<li><code>:cs find e xxx</code> 使用 egrep pattern 查詢</li>
<li><code>:cs find f xxx</code> 找出 xxx 檔案在哪裡</li>
<li><code>:cs find g xxx</code> 查尋 xxx 所定義的地方 (通常最常用的是這個)</li>
<li><code>:cs find i xxx</code> 查尋所有 inlcude xxx 檔案的地方</li>
<li><code>:cs find s xxx</code> 查尋所有 xxx symbol 出現的地方</li>
<li><code>:cs find t xxx</code> 查詢 xxx 字串出現的地方，其實搜尋效果就類似 grep</li>
</ul>
<p>記得查詢完的結果可以用 <code>:cw</code>, <code>:copen</code> 在 quickfix window 列出：</p>
<h1 id=gnu-global-gtags>GNU GLOBAL (gtags)<a hidden class=anchor aria-hidden=true href=#gnu-global-gtags>#</a></h1>
<p>由 GNU GLOBAL 由 GNU 所開發的 soure code tagging system，本身支持四種語言，透過 Pygments 和 Universal Ctags 的 parser 可以支持其他 25 種語言，支援 incremental update，原始碼更動後，只會對改變的地方索引，不會重新索引，這對龐大的專案有很大的幫助。另外 gtags 提供了 cscope 相容的互動介面，叫做 gtags-cscope，讓你用起來像 cscope，但背後其實是 gtags 的索引檔案。</p>
<p>在專案目錄產生索引檔案：</p>
<pre><code>$ gtags
</code></pre><p>讓 vim 知道 gtags-cscope 路徑：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-vim data-lang=vim>:<span style=color:#a6e22e>set</span> <span style=color:#a6e22e>cscopeprg</span>=<span style=color:#e6db74>/path/</span><span style=color:#a6e22e>to</span>/<span style=color:#a6e22e>gtsgs</span>-<span style=color:#a6e22e>cscope</span><span style=color:#960050;background-color:#1e0010>
</span></code></pre></div><p>指定 gtags 索引檔案，讓 vim 知道要用哪個索引檔案查詢：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-vim data-lang=vim>:<span style=color:#a6e22e>cs</span> <span style=color:#a6e22e>add</span> <span style=color:#a6e22e>GTAGS</span><span style=color:#960050;background-color:#1e0010>
</span></code></pre></div><p>借下來就可以用和 cscope 一樣的方式查詢，除了 <code>:cs find d</code>，其他皆支援</p>
<h1 id=ctags>Ctags<a hidden class=anchor aria-hidden=true href=#ctags>#</a></h1>
<h2 id=ctags-簡介>Ctags 簡介<a hidden class=anchor aria-hidden=true href=#ctags-簡介>#</a></h2>
<p>最早的 Ctag 在 BSD 上實現，版本變革的歷史脈絡我不是相當清楚，查不太到資料。
現在普及的版本是 Exuberant Ctags，一開始和 vim 是一包軟體，一起發布，但在 vim6 之後獨立成兩個專案，從這裏可看出它一定和 vim 兼容良好，但此版本在 2009 年之後已不再維護。建議使用Exuberant Ctags 所 fork 的版本 Universal Ctags，目前還在維護和開發當中。</p>
<h2 id=ctags-和-vim>Ctags 和 vim<a hidden class=anchor aria-hidden=true href=#ctags-和-vim>#</a></h2>
<p>在專案下生成索引檔案，可以看到目錄裡有 <code>tags</code> 檔案</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ ctags -R *
</code></pre></div><p>指定 tags 索引檔案，讓 vim 知道要用哪個索引檔案查詢：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-vim data-lang=vim>:<span style=color:#a6e22e>set</span> <span style=color:#a6e22e>tags</span>=<span style=color:#a6e22e>tags</span><span style=color:#960050;background-color:#1e0010>
</span></code></pre></div><p>再來就可以使用:</p>
<ul>
<li><code>Ctrl + ]</code>: 跳到定義，如果有多個匹配則會跳到第一個</li>
<li><code>Ctrl + T</code>: 跳回原本的地方</li>
</ul>
<p>每次用 <code>ctrl + ]</code> 跳轉到定義，vim 就會把這位置推到 tag stack 裡，每次 <code>ctrl + T</code> 跳回原來的地方，vim 就會從 tag stack 裡 pop 位置出來，我們可以使用 <code>:tags</code> 看到 tag stack 裡的內容。</p>
<h1 id=reference>Reference<a hidden class=anchor aria-hidden=true href=#reference>#</a></h1>
<ul>
<li>
<p><a href=https://dev.to/iggredible/how-to-use-tags-in-vim-to-jump-to-definitions-quickly-2g28>https://dev.to/iggredible/how-to-use-tags-in-vim-to-jump-to-definitions-quickly-2g28</a></p>
</li>
<li>
<p><a href=http://praton.me/2020/04/11/Exploring-kernel-code-with-vim.html>http://praton.me/2020/04/11/Exploring-kernel-code-with-vim.html</a></p>
</li>
<li>
<p><a href=https://neovim.io/doc/user/usr_29.html>:help usr_29.txt</a></p>
</li>
<li>
<p><a href=https://neovim.io/doc/user/usr_30.html>:help usr_30.txt</a></p>
</li>
<li>
<p><a href=https://neovim.io/doc/user/tagsrch.html>:help tagsrch.txt</a></p>
</li>
</ul>
</div>
<footer class=post-footer>
<ul class=post-tags>
<li><a href=https://amikai.github.io/tags/vim/>vim</a></li>
<li><a href=https://amikai.github.io/tags/neovim/>neovim</a></li>
<li><a href=https://amikai.github.io/tags/c/>c</a></li>
</ul>
</footer>
<div id=disqus_thread></div>
<script type=application/javascript>var disqus_config=function(){};(function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById('disqus_thread').innerHTML='Disqus comments not available by default when the website is previewed locally.';return}var b=document,a=b.createElement('script');a.async=!0,a.src='//amikai-github-io.disqus.com/embed.js',a.setAttribute('data-timestamp',+new Date),(b.head||b.body).appendChild(a)})()</script>
<noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript>
<a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a>
</article>
</main><footer class=footer>
<span>&copy; 2021 <a href=https://amikai.github.io/>no code no pain</a></span>
<span>&#183;</span>
<span>Powered by <a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a></span>
<span>&#183;</span>
<span>Theme <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span>
</footer>
<a href=#top aria-label="go to top" title="Go to Top (Alt + G)">
<button class=top-link id=top-link type=button accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</button>
</a>
<script defer src=/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5+kdJvBz5iKbt6B5PJI=" onload=hljs.initHighlightingOnLoad()></script>
<script>window.onload=function(){localStorage.getItem("menu-scroll-position")&&(document.getElementById('menu').scrollLeft=localStorage.getItem("menu-scroll-position"))};function menu_on_scroll(){localStorage.setItem("menu-scroll-position",document.getElementById('menu').scrollLeft)}document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script>
<script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script>
<script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script>
</body>
</html>