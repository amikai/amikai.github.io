<!doctype html><html lang=zh dir=auto>
<head><meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<meta name=robots content="index, follow">
<title>vim | no code no pain</title>
<meta name=keywords content>
<meta name=description content="amikai's blog, my learning notes about backend, golang, (neo)vim, k8s, etc.">
<meta name=author content="amikai">
<link rel=canonical href=https://amikai.github.io/tags/vim/>
<link href=/assets/css/stylesheet.min.746a86b58bb2b052b5e4df8216510494f04f81e62c08d626150c26c69ca929da.css integrity="sha256-dGqGtYuysFK15N+CFlEElPBPgeYsCNYmFQwmxpypKdo=" rel="preload stylesheet" as=style>
<link rel=icon href=https://amikai.github.io/favicon.ico>
<link rel=icon type=image/png sizes=16x16 href=https://amikai.github.io/favicon-16x16.png>
<link rel=icon type=image/png sizes=32x32 href=https://amikai.github.io/favicon-32x32.png>
<link rel=apple-touch-icon href=https://amikai.github.io/apple-touch-icon.png>
<link rel=mask-icon href=https://amikai.github.io/safari-pinned-tab.svg>
<meta name=theme-color content="#2e2e33">
<meta name=msapplication-TileColor content="#2e2e33">
<meta name=generator content="Hugo 0.86.0">
<link rel=alternate type=application/rss+xml href=https://amikai.github.io/tags/vim/index.xml>
<link rel=alternate hreflang=zh href=https://amikai.github.io/tags/vim/>
<script type=application/javascript>var doNotTrack=!1;doNotTrack||(window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga('create','UA-172478407-1','auto'),ga('send','pageview'))</script>
<script async src=https://www.google-analytics.com/analytics.js></script>
<meta property="og:title" content="vim">
<meta property="og:description" content="amikai's blog, my learning notes about backend, golang, (neo)vim, k8s, etc.">
<meta property="og:type" content="website">
<meta property="og:url" content="https://amikai.github.io/tags/vim/">
<meta name=twitter:card content="summary">
<meta name=twitter:title content="vim">
<meta name=twitter:description content="amikai's blog, my learning notes about backend, golang, (neo)vim, k8s, etc.">
</head>
<body class=list id=top>
<script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script>
<noscript>
<style type=text/css>#theme-toggle,.top-link{display:none}</style>
<style>@media(prefers-color-scheme:dark){:root{--theme:#1d1e20;--entry:#2e2e33;--primary:rgba(255, 255, 255, 0.84);--secondary:rgba(255, 255, 255, 0.56);--tertiary:rgba(255, 255, 255, 0.16);--content:rgba(255, 255, 255, 0.74);--hljs-bg:#2e2e33;--code-bg:#37383e;--border:#333}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style>
</noscript>
<header class=header>
<nav class=nav>
<div class=logo>
<a href=https://amikai.github.io/ accesskey=h title="no code no pain (Alt + H)">no code no pain</a>
<span class=logo-switches>
<button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg>
</button>
<ul class=lang-switch><li>|</li>
<li>
<a href=https://amikai.github.io/en/ title=English aria-label=English>English</a>
</li>
</ul>
</span>
</div>
<ul id=menu onscroll=menu_on_scroll()>
<li>
<a href=https://amikai.github.io/archives title=Archive>
<span>Archive</span>
</a>
</li>
<li>
<a href=https://amikai.github.io/categories/ title=Categories>
<span>Categories</span>
</a>
</li>
<li>
<a href=https://amikai.github.io/tags/ title=Tags>
<span>Tags</span>
</a>
</li></ul>
</nav>
</header>
<main class=main>
<header class=page-header>
<h1>vim</h1>
</header>
<article class="post-entry tag-entry">
<header class=entry-header>
<h2>
好用的 vim virtualedit 選項
</h2>
</header>
<section class=entry-content>
<p>使用 ctrl+v 把一個圖片中的英文字母區塊刪掉會像以下這樣 顯然是不如預期 set virtualedit=block 設定了此選項之後 什麼是 virutaledit 在 vim 裡預設行為：游標無法放在沒有字元的地方，也就是 set virtualedit=。 所以 set virtualedit=block 指的是在 block mode 裡 (也就是 ctrl + v) 可以將游標移到沒有字元的位置
Reference :help virtualedit </p>
</section>
<footer class=entry-footer>
May 23, 2021&nbsp;·&nbsp;amikai
</footer>
<a class=entry-link aria-label="post link to 好用的 vim virtualedit 選項" href=https://amikai.github.io/2021/05/23/vim-virtualedit/></a>
</article>
<article class="post-entry tag-entry">
<header class=entry-header>
<h2>
在 (neo)vim 裡 C 語言程式碼導覽技巧
</h2>
</header>
<section class=entry-content>
<p>現代的專案開發，很少在從無到有打造，大部分都是基於現有的程式之上繼續開發或維護，進入專案之後，通常第一件事就是大量閱讀程式碼理清專案的整個脈絡，才開始著手寫 code，所以好的程式碼導覽技巧將會帶你上天堂。
我將大部分的程式碼導覽情境大致拆成了三種情況：
基本的跳轉： #if #endif 中間的程式碼太長，想要跳轉到成對的 #if #endif cursor 在 {…} block 裡， 這個 block 又臭又長，想快速跳轉 block 的開頭和結尾 註解長篇大論，想快速跳到註解的開頭或結尾 尋找專案下檔案 (可透過設定 path option 解決) 跳轉到標頭檔 跳轉到指定檔案 使用 source code tagging system 快速挑轉到 function 定義及特定 symbol 等等： 專案相當大的時候，source code tagging system 相當好用，可以快速找到定位，也不會花掉太多的資源，比起 LSP 的跳轉定義，是較輕量的選擇。 本篇依據上述三種情境，一一講述。
常用跳轉操作 %
跳到成對的括號 如果註解是 /*...*/，跳到成對的註解符號 在成對的 #if, #ifdef, #else, #elif, #endif 之中跳轉，這相當重要，如果 code 很長, if else macro 又是巢狀的，這招可以讓你少迷路好幾次 [{ ]}...</p>
</section>
<footer class=entry-footer>
November 28, 2020&nbsp;·&nbsp;amikai
</footer>
<a class=entry-link aria-label="post link to 在 (neo)vim 裡 C 語言程式碼導覽技巧" href=https://amikai.github.io/2020/11/28/vim-c-env-move/></a>
</article>
<article class="post-entry tag-entry">
<header class=entry-header>
<h2>
聊聊你在 vim 常用的移動方式
</h2>
</header>
<section class=entry-content>
<p>看下圖，如果想將 &lt;expr> 改成 &lt;leader> 你會怎麼做呢? {% asset_img question.png %}
通常我看過的幾種方式如下：
使用 j 向下到 97 行，在使用 l 到 target 並且開始編輯，這也是最糟的 target 的行數看起來離 window 中央行很近， 使用 M 跳到 window 中央行，再使用 h j k l 到 target 使用 :set number 列出行號， 按下 97G 到達 97 行， fe ; ; ; 註: f{char} 找到此行的下一個字母、 ; 為重複上一個 f 命令 使用 / 搜尋 expr，在使用 n n n n 到 target 使用 set mouse=n，用滑鼠點 target Easymotion easymotion 是解決此情境最好的方案之一，它提供了另一種搜尋方式，在搜尋目標之後，會將可能位置的抽換成其他字母，並高亮這些字母，再按下這些字母就可以跳到此位置 (之後簡稱為 label and jump 功能)。 easymotion 的設計就是加強內建的移動指令，只是跳轉到目標的方式變了，所以不需要擔心不會用。...</p>
</section>
<footer class=entry-footer>
October 3, 2020&nbsp;·&nbsp;amikai
</footer>
<a class=entry-link aria-label="post link to 聊聊你在 vim 常用的移動方式" href=https://amikai.github.io/2020/10/03/vim-commonly-used-motion/></a>
</article>
<article class="post-entry tag-entry">
<header class=entry-header>
<h2>
vim 高亮 yank 區域
</h2>
</header>
<section class=entry-content>
<p>y 是在 vim 裡最常使用的使用的 operator 之一，使用 y operator 將會執行 yank 動作，但它無法像 c (change) 和 d (delete) operator 使用之後馬上就知道對文件編輯了什麼。yank 動作是沒有反饋的，按了 yiw 複製 word 之後，你也無法確定是不是按對了，還要使用 :reg 檢視，頗麻煩的。
解決方案：在使用 yank operator 之後，高亮複製區域短暫的時間，就能確認複製的區域有沒有誤。以下圖例為，在 23 行按下 yy, 在 24 行的 return 上按下 yiw
在 neovim 0.5 裡達到這件事相當簡單，把以下加近
autocmd TextYankPost * silent! lua vim.highlight.on_yank{higroup="IncSearch", timeout=300}如果是使用 vim 也可以用 vim-highlightedyank 套件達成
Plug 'machakann/vim-highlightedyank'let g:highlightedyank_highlight_duration = 300if !exists('##TextYankPost') map y &lt;Plug>(highlightedyank)endifReference https://github.com/neovim/neovim/pull/12279 neovim :help lua-highlight </p>
</section>
<footer class=entry-footer>
September 29, 2020&nbsp;·&nbsp;amikai
</footer>
<a class=entry-link aria-label="post link to vim 高亮 yank 區域" href=https://amikai.github.io/2020/09/29/vim-tips-highlight-yank-region/></a>
</article>
<article class="post-entry tag-entry">
<header class=entry-header>
<h2>
你應該擴充的 text object
</h2>
</header>
<section class=entry-content>
<p>vim 高效率編輯的背後，operator, motion, text object 的配合功不可沒。
operator 是編輯的動作， text object 就是文字區塊，motion 是跳轉到文件點，透過三者的按鍵配合，就能達到所想及所得的編輯方式。
如果你有看過別人使用 vim ，通常會有這種想法：怎麼隨便按幾個鍵就刪這裡刪那裡複製這裡複製那裡，速度快到看不懂在幹嘛，而且還不會出錯，因為只要想好要做什麼，按鍵按下去就對了，這也是為什麼會高效率。說了一堆，反正就是 耍潮必備。
本篇將會提到:
operator, text object, motion 的配合用法 內建 text object 的不足之處 擴充 text object 的 plugin 淺談 nvim-treesitter Operator & text object Vim 定義了多個 operator 最常用的就是:
d delete (刪除) c change (更改) y yank (複製) operator 沒有配合 text object 或是 motion 是沒有意義的，想像一下使用了 d 刪除，但是沒告訴它要刪除什麼，就像有了鐵鎚不知道要打什麼。所以需要給 operator 一個目標，讓它要對誰做什麼。這個誰就有兩種，motion 和 text object。
motion：其實就是跳轉指令，像是常用的 G,gg, w, f{char} … 等都可以配合 operator。基本使用方法為 {operator}{motion}，語意就是做這個 operator 動作到 motion 所到的地方...</p>
</section>
<footer class=entry-footer>
September 22, 2020&nbsp;·&nbsp;amikai
</footer>
<a class=entry-link aria-label="post link to 你應該擴充的 text object" href=https://amikai.github.io/2020/09/22/vim-text-object/></a>
</article>
<article class="post-entry tag-entry">
<header class=entry-header>
<h2>
誰說不能在 vim 裡編譯，從 :make 到 :Make
</h2>
</header>
<section class=entry-content>
<p>前言 回想一下，上一次使用 vim 寫 code 到一個段落要編譯時，你是怎麼做的。
我看到大多數人的方式，就是將 terminal 切成兩塊，一塊寫 code，一塊編譯，若編譯有錯誤，再移動到寫 code 區塊更改。 如果使用此方法，當專案有規模時，編譯錯誤一百條，看了編譯錯誤在哪之後，再將編譯錯誤的位置，從專案裡找出來，反覆來回 100 次，直到修正完畢。 本文以 C 語言專案為例 (當然不是只有 C 語言才能這樣子幹，可看 Q&A)，聊聊強大的 vim 在這種情境下有什麼好的解決方案。 強大的 :make 基本款 此次範例就拿 neovim 來編譯好了，根據官方文件要這樣編譯 make CMAKE_BUILD_TYPE=Release，所以在我在 vim 裡這樣編 :make CMAKE_BUILD_TYPE=Release
看起來噴了一點錯誤，案了 enter 似乎之後什麼事都沒發生，回到平常。 用 :cl 指令，喔幹!不是一點錯誤，是一堆錯誤，沒列出來根本不知道。 重點來了!! 可以使用 :cn (:cnext) 跳到下一個錯誤位置，:cp (:cprevious) 跳轉到上一個錯誤位置，就不需要自己手動一個一個錯誤找出來。 看上圖，可以觀察到，每一條錯誤前面都有一個數字，如果想要跳到特定錯誤去修那就使用 :cc [number]，跳轉到第一個錯誤就用 :cc 12，跳轉到第三個錯誤就用 :cc 19。
火力展示: 總結一下指令:
:make: 執行 makefile :cl: 列出所有錯誤 :cn: 跳到下個錯誤 :cp: 跳到上個錯誤 :cc [number]: 跳轉到特定錯誤 如虎添翼的 quickfix-window 編譯完之後，除了用 :cl 查看，另一種方式就是用 :copen，打下此指令之後，將會彈出 quickfix-window，列出的錯誤其實就是 :clist 的詳細版本， quickfix-window 只是提供了一種查找的方式。 移轉到 quickfix-window 後，移動到想要查看的錯誤，案 enter 即可跳轉到該錯誤位置，當然也能配合 :cn, :cp, :cc [number]，quickfix-window 會配合這些指令連動顯示目前位置。...</p>
</section>
<footer class=entry-footer>
September 10, 2020&nbsp;·&nbsp;amikai
</footer>
<a class=entry-link aria-label="post link to 誰說不能在 vim 裡編譯，從 :make 到 :Make" href=https://amikai.github.io/2020/09/10/vim-make/></a>
</article>
<article class="post-entry tag-entry">
<header class=entry-header>
<h2>
聊聊 vim mark 使用情境 - code 參照
</h2>
</header>
<section class=entry-content>
<p>寫程式的時候常常遇到一種情況，假設你是團隊的新人，需要常常參照別人的程式，看看團隊的 coding style 等等，可能需要參照 A file 的第 10 行，B file 第 8 行，C file 第 999 行。
另一種情境則是在寫測試的時候會和實作交互參照，而測試程式往往和實作程式會拆開不同的檔案，所以就必須要一直跳轉。
使用 split 的方式縱然是一個不錯的方式，但是如果要參照的點大於三個，就將螢幕切成三份，那工程師就相當痛苦了，不是每個人都用這種電腦螢幕啊。這種 split 的方式還有另一個缺點：如果手殘將檔案關掉，就得重找。 Mark vim 的 mark 取名或許源自於 bookmark (書籤) 這個字，書籤的用意在於能快速找回你上次看的那一頁，而 vim mark 的用意也是如此：能快速找回你剛剛在看 code 的地方。
vim 的 mark 分為三種：
Local mark a-z： 每一個 file 裡皆有自己的 local mark，也就是說檔案 A 可以有 mark a, 檔案 B 裡也可以有自己的 mark a Global mark A-Z： 此種 mark 是全域的，也就是說在檔案 A 裡所看到的 mark A 和 B 檔案 B 裡的 mark A 是一樣的 Special mark：其他神奇的 mark，不在此文章討論範圍 mark 的基本使用：...</p>
</section>
<footer class=entry-footer>
September 7, 2020&nbsp;·&nbsp;amikai
</footer>
<a class=entry-link aria-label="post link to 聊聊 vim mark 使用情境 - code 參照" href=https://amikai.github.io/2020/09/07/vim-mark-tips/></a>
</article>
<article class="post-entry tag-entry">
<header class=entry-header>
<h2>
Golang 開發環境 - 使用 neovim
</h2>
</header>
<section class=entry-content>
<p>你確定要用 neovim 開發 golang? 現在是 vscode 稱霸天下的時代，理所當然的 (neo)vim 也常常被拿來 vscode 比較，vscode 內建整合了 git、debugger、自動補全引擎、terminal、extension manager，另外 Golang 在 vscode 上的 extension 支援相當良好: 包括跳轉到定義 (go to definition)、重新命名 (rename)、跳轉到型態定義 (go to type definition)⋯⋯ 一堆細節功能，近期由於 google golang team 接手 go 語言的 vscode extension，相信使用 vscode 開發是不錯的選擇。
(neo)vim 當然也能達到 vscode 的類似功能，但是必須花時間設定調教，在 vscode 問世之前我會推薦 (Neo)vim 給我的朋友，vscode 問世之後我就開始推薦 vscode。
本文給那些本來就在 (neo)vim 裡打滾的人，但對 go 語言設定不熟的人， 如果你是一張白紙，而且沒有被虐的癖好，我建議選擇 vscode，可以用較少的時間進入到寫程式的環節，而不是一直在花時間在設定，這篇文你也沒必要看下去。
預備動作 Must have
你應該先安裝好 neovim nightly 版本，brew install neovim --HEAD 你應該要知道怎麼使用 vim-plug，至少要知道 :PlugInstall 你應該先把 go 語言環境安裝好 Nice to have...</p>
</section>
<footer class=entry-footer>
September 3, 2020&nbsp;·&nbsp;amikai
</footer>
<a class=entry-link aria-label="post link to Golang 開發環境 - 使用 neovim" href=https://amikai.github.io/2020/09/03/go_neovim_env/></a>
</article>
</main><footer class=footer>
<span>&copy; 2021 <a href=https://amikai.github.io/>no code no pain</a></span>
<span>&#183;</span>
<span>Powered by <a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a></span>
<span>&#183;</span>
<span>Theme <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span>
</footer>
<a href=#top aria-label="go to top" title="Go to Top (Alt + G)">
<button class=top-link id=top-link type=button accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</button>
</a>
<script>window.onload=function(){localStorage.getItem("menu-scroll-position")&&(document.getElementById('menu').scrollLeft=localStorage.getItem("menu-scroll-position"))};function menu_on_scroll(){localStorage.setItem("menu-scroll-position",document.getElementById('menu').scrollLeft)}document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script>
<script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script>
<script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script>
</body>
</html>