<!doctype html><html lang=zh dir=auto>
<head><meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<meta name=robots content="index, follow">
<title>Dockerfile - Multi-stage build 筆記 | no code no pain</title>
<meta name=keywords content="docker">
<meta name=description content="在專案開發時，通常會執行代碼檢查、單元測試、編譯、執行等等。
在 docker 還沒出現之前，這些流程都是在本機上跑 (版本 0)，因為環境的不一致可能導致不同主機執行結果不相同。將這些流程步驟撰寫成 dockerfile 直接在容器裡執行就可以解決上述問題 (版本 1)，但也衍伸出了新的問題。為了執行代碼檢查和編譯，下載了許多套件或是相依工具，造成映像檔肥大，很多套件或是相依工具在部署時是不需要的。
如果把這些步驟拆成兩個階段思考 (版本 2)
 開發整合階段：代碼檢查、單元測試、編譯等等使用。 部署階段：跑起執行檔，將此兩階段寫成兩個 dockerfile，並且建構出兩個映像檔，只要拿後者映像檔去部署即可。 版本 2 成功解決了部署映像檔大小的問題，可是在必須維護兩個 dockerfile 還有中間流程所需的 script，Docker 17.05 所推出的 Multi-stage build 正好能解決此問題 (版本 3)。  以下則是 版本 0 進化到 版本 3 的過程及解釋。
範例 go 專案，版本 0：沒使用 docker 此專案使用 gin 實作 http server 只要對它請求 GET /ping ，則會回覆 pong， 以下是專案結構：
> tree example example ├── go.mod ├── go.sum ├── main.go └── main_test.go 在完成程式碼撰寫之後，執行以下步驟
 使用 go vet 檢查 使用 staticcheck 檢查 跑完測試 編譯專案 執行  $ go vet .">
<meta name=author content="amikai">
<link rel=canonical href=https://amikai.github.io/2021/03/01/docker-multi-stage-build/>
<link href=/assets/css/stylesheet.min.1e4b51002afd206b67ec98785f7d3a6d4fd0feb374e07bb018954cad57795586.css integrity="sha256-HktRACr9IGtn7Jh4X306bU/Q/rN04HuwGJVMrVd5VYY=" rel="preload stylesheet" as=style>
<link rel=icon href=https://amikai.github.io/favicon.ico>
<link rel=icon type=image/png sizes=16x16 href=https://amikai.github.io/favicon-16x16.png>
<link rel=icon type=image/png sizes=32x32 href=https://amikai.github.io/favicon-32x32.png>
<link rel=apple-touch-icon href=https://amikai.github.io/apple-touch-icon.png>
<link rel=mask-icon href=https://amikai.github.io/safari-pinned-tab.svg>
<meta name=theme-color content="#2e2e33">
<meta name=msapplication-TileColor content="#2e2e33">
<meta name=generator content="Hugo 0.86.0">
<link rel=alternate hreflang=zh href=https://amikai.github.io/2021/03/01/docker-multi-stage-build/>
<script type=application/javascript>var doNotTrack=!1;doNotTrack||(window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga('create','UA-172478407-1','auto'),ga('send','pageview'))</script>
<script async src=https://www.google-analytics.com/analytics.js></script>
<meta property="og:title" content="Dockerfile -  Multi-stage build 筆記">
<meta property="og:description" content="在專案開發時，通常會執行代碼檢查、單元測試、編譯、執行等等。
在 docker 還沒出現之前，這些流程都是在本機上跑 (版本 0)，因為環境的不一致可能導致不同主機執行結果不相同。將這些流程步驟撰寫成 dockerfile 直接在容器裡執行就可以解決上述問題 (版本 1)，但也衍伸出了新的問題。為了執行代碼檢查和編譯，下載了許多套件或是相依工具，造成映像檔肥大，很多套件或是相依工具在部署時是不需要的。
如果把這些步驟拆成兩個階段思考 (版本 2)
 開發整合階段：代碼檢查、單元測試、編譯等等使用。 部署階段：跑起執行檔，將此兩階段寫成兩個 dockerfile，並且建構出兩個映像檔，只要拿後者映像檔去部署即可。 版本 2 成功解決了部署映像檔大小的問題，可是在必須維護兩個 dockerfile 還有中間流程所需的 script，Docker 17.05 所推出的 Multi-stage build 正好能解決此問題 (版本 3)。  以下則是 版本 0 進化到 版本 3 的過程及解釋。
範例 go 專案，版本 0：沒使用 docker 此專案使用 gin 實作 http server 只要對它請求 GET /ping ，則會回覆 pong， 以下是專案結構：
> tree example example ├── go.mod ├── go.sum ├── main.go └── main_test.go 在完成程式碼撰寫之後，執行以下步驟
 使用 go vet 檢查 使用 staticcheck 檢查 跑完測試 編譯專案 執行  $ go vet .">
<meta property="og:type" content="article">
<meta property="og:url" content="https://amikai.github.io/2021/03/01/docker-multi-stage-build/"><meta property="article:section" content="posts">
<meta property="article:published_time" content="2021-03-01T21:57:33+00:00">
<meta property="article:modified_time" content="2021-03-01T21:57:33+00:00">
<meta name=twitter:card content="summary">
<meta name=twitter:title content="Dockerfile -  Multi-stage build 筆記">
<meta name=twitter:description content="在專案開發時，通常會執行代碼檢查、單元測試、編譯、執行等等。
在 docker 還沒出現之前，這些流程都是在本機上跑 (版本 0)，因為環境的不一致可能導致不同主機執行結果不相同。將這些流程步驟撰寫成 dockerfile 直接在容器裡執行就可以解決上述問題 (版本 1)，但也衍伸出了新的問題。為了執行代碼檢查和編譯，下載了許多套件或是相依工具，造成映像檔肥大，很多套件或是相依工具在部署時是不需要的。
如果把這些步驟拆成兩個階段思考 (版本 2)
 開發整合階段：代碼檢查、單元測試、編譯等等使用。 部署階段：跑起執行檔，將此兩階段寫成兩個 dockerfile，並且建構出兩個映像檔，只要拿後者映像檔去部署即可。 版本 2 成功解決了部署映像檔大小的問題，可是在必須維護兩個 dockerfile 還有中間流程所需的 script，Docker 17.05 所推出的 Multi-stage build 正好能解決此問題 (版本 3)。  以下則是 版本 0 進化到 版本 3 的過程及解釋。
範例 go 專案，版本 0：沒使用 docker 此專案使用 gin 實作 http server 只要對它請求 GET /ping ，則會回覆 pong， 以下是專案結構：
> tree example example ├── go.mod ├── go.sum ├── main.go └── main_test.go 在完成程式碼撰寫之後，執行以下步驟
 使用 go vet 檢查 使用 staticcheck 檢查 跑完測試 編譯專案 執行  $ go vet .">
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://amikai.github.io/posts/"},{"@type":"ListItem","position":3,"name":"Dockerfile -  Multi-stage build 筆記","item":"https://amikai.github.io/2021/03/01/docker-multi-stage-build/"}]}</script>
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Dockerfile -  Multi-stage build 筆記","name":"Dockerfile -  Multi-stage build 筆記","description":"在專案開發時，通常會執行代碼檢查、單元測試、編譯、執行等等。\n在 docker 還沒出現之前，這些流程都是在本機上跑 (版本 0)，因為環境的不一致可能導致不同主機執行結果不相同。將這些流程步驟撰寫成 dockerfile 直接在容器裡執行就可以解決上述問題 (版本 1)，但也衍伸出了新的問題。為了執行代碼檢查和編譯，下載了許多套件或是相依工具，造成映像檔肥大，很多套件或是相依工具在部署時是不需要的。\n如果把這些步驟拆成兩個階段思考 (版本 2)\n 開發整合階段：代碼檢查、單元測試、編譯等等使用。 部署階段：跑起執行檔，將此兩階段寫成兩個 dockerfile，並且建構出兩個映像檔，只要拿後者映像檔去部署即可。 版本 2 成功解決了部署映像檔大小的問題，可是在必須維護兩個 dockerfile 還有中間流程所需的 script，Docker 17.05 所推出的 Multi-stage build 正好能解決此問題 (版本 3)。  以下則是 版本 0 進化到 版本 3 的過程及解釋。\n範例 go 專案，版本 0：沒使用 docker 此專案使用 gin 實作 http server 只要對它請求 GET /ping ，則會回覆 pong， 以下是專案結構：\n\u0026gt; tree example example ├── go.mod ├── go.sum ├── main.go └── main_test.go 在完成程式碼撰寫之後，執行以下步驟\n 使用 go vet 檢查 使用 staticcheck 檢查 跑完測試 編譯專案 執行  $ go vet .","keywords":["docker"],"articleBody":"在專案開發時，通常會執行代碼檢查、單元測試、編譯、執行等等。\n在 docker 還沒出現之前，這些流程都是在本機上跑 (版本 0)，因為環境的不一致可能導致不同主機執行結果不相同。將這些流程步驟撰寫成 dockerfile 直接在容器裡執行就可以解決上述問題 (版本 1)，但也衍伸出了新的問題。為了執行代碼檢查和編譯，下載了許多套件或是相依工具，造成映像檔肥大，很多套件或是相依工具在部署時是不需要的。\n如果把這些步驟拆成兩個階段思考 (版本 2)\n 開發整合階段：代碼檢查、單元測試、編譯等等使用。 部署階段：跑起執行檔，將此兩階段寫成兩個 dockerfile，並且建構出兩個映像檔，只要拿後者映像檔去部署即可。 版本 2 成功解決了部署映像檔大小的問題，可是在必須維護兩個 dockerfile 還有中間流程所需的 script，Docker 17.05 所推出的 Multi-stage build 正好能解決此問題 (版本 3)。  以下則是 版本 0 進化到 版本 3 的過程及解釋。\n範例 go 專案，版本 0：沒使用 docker 此專案使用 gin 實作 http server 只要對它請求 GET /ping ，則會回覆 pong， 以下是專案結構：\n tree example example ├── go.mod ├── go.sum ├── main.go └── main_test.go 在完成程式碼撰寫之後，執行以下步驟\n 使用 go vet 檢查 使用 staticcheck 檢查 跑完測試 編譯專案 執行  $ go vet ./... $ staticcheck ./... $ go test ./... $ go build -o ./server $ ./server Dockerfile 版本一： 全部都塞在一個映像檔 FROMgolang:1.16.0-alpine3.13# go moduleENV GO111MODULE=on CGO_ENABLED=0 # install staticcheck binaryRUN go install honnef.co/go/tools/cmd/staticcheck@v0.1.2WORKDIR/workspace/example# download dependencyCOPY go.mod go.sum .RUN go mod download# Copy source codeCOPY . ./RUN go vet ./... \u0026\u0026 staticcheck ./... \u0026\u0026 go test ./... \u0026\u0026 go build -o /bin/server把映像檔做出來\n$ docker image build -t amikai/example:v1 . 為了要對此專案進行代碼檢查和編譯，必須將相關工具以及依賴下載好，而這些依賴及工具都會佔用到空間，觀察 container 裡 /go (go 相關依賴) 就佔了 328.7 MB (使用 du -sh /go 觀察)，而整個映像檔是 687 MB，映像檔大小還有相當大的改善空間。\nDockerfile 版本二：拆成兩個階段思考 把版本一的 dockfile 拆成兩個階段思考：\n 從建構的階段來想：為了確保每個人在代碼檢查以及編譯的環境是統一的，減少環境不同所造成的問題。 從部署的階段來想：最後只要留下需要編譯後所產生的執行檔，其他相關的依賴和工具都是不必要的，編譯完後放在那只是佔位置。  把這兩個階段的事情，拆成兩個映像檔：\n 建構階段 (Dockerfile)：此階段是對原始碼進行檢查及編譯等等，不太需要考慮映像檔大小，反正不會拿去部署。 部署階段 (Dockerfile.build)： 此在意的是映像檔大小，所以留下編譯後的執行檔即可。  具體的做法就是先做出一個 Dockerfile.build 去 build 出執行檔，把此執行檔取出，再寫一個 Dockerfile 將此執行檔放入，開始執行。在使用一個 build.sh 將上述事情自動化。\nDockerfile.build\nFROMgolang:1.16.0-alpine3.13# go moduleENV GO111MODULE=on CGO_ENABLED=0 # install staticcheck binaryRUN go install honnef.co/go/tools/cmd/staticcheck@v0.1.2WORKDIR/workspace/example# download dependencyCOPY go.mod go.sum .RUN go mod download# Copy source codeCOPY . ./RUN go vet ./... \u0026\u0026 staticcheck ./... \u0026\u0026 go test ./... \u0026\u0026 go build -o /bin/serverDockerfile\nFROMalpine:latestWORKDIR/root/COPY server .ENTRYPOINT [\"./server\"]build.sh\n#!/bin/sh echo Building amikai/example:build docker build -t amikai/example:build . -f Dockerfile.build docker container create --name extract amikai/example:build docker container cp extract:/bin/server ./server docker container rm -f extract echo Building amikai/example:v2 docker image build --no-cache -t amikai/example:v2 . 執行 build.sh 將 example:v2 的映像檔做出來，這個映像檔大小是 15 MB，已經和版本一的 687 MB 有很大的進步空間。\n雖然最終產出的映像檔大小有極大的改善，但為了這個映像檔，必須維護三個檔案，在微服務的世界裡，如果一個容器裝一個服務，就必須維護 服務數量 * 3 的檔案。\n而且是兩個映像檔分別都會佔用到硬碟空間，也就是說雖然拿來部署的映像檔改善了大小，但總體佔用的硬碟空間和版本一是幾乎一樣的。\nDockerfile 版本三： multi-stage builds docker 在 17.05 提出 multi-stage builds，整個 dockerfile 可以分割成好幾個 stage，每個 stage 由 FROM 作為開始，也就是說 FROM 除了選擇基底映像檔之外，還有新 stage 起始的意義。\nmulti-stage 功能讓我們可以將此 stage 所需要的檔案，複製到下個 stage 做其他事，則最終做出來的映像檔只會留下所需的檔案。\n版本三的 dockerfile 如下，有兩個 stage:\n builder stage: 以 golang 為基底的映像檔，用來做原始碼檢查、測試，並且編譯出執行檔 release stage: 將 builder stage 的執行檔複製過來，並且執行  FROMgolang:1.16.0-alpine3.13 AS builderWORKDIR/workspace/exampleENV GO111MODULE=on CGO_ENABLED=0 # download dependencyCOPY go.mod go.sum .RUN go mod downloadRUN go install honnef.co/go/tools/cmd/staticcheck@v0.1.2COPY . .RUN go vet ./... \u0026\u0026 staticcheck ./... \u0026\u0026 go test ./... \u0026\u0026 go build -o /bin/serverFROMalpine:latest AS release# Copy from builderCOPY --from=builder /bin/server /bin/serverENTRYPOINT [\"./bin/server\"]把映像檔做出來\n$ docker image build -t amikai/example:v3 . 版本三的映像檔大小為 15 MB，解決了版本二不需要維護三個檔案也解決了版本一產出肥大映像檔的痛點。multi-stage builds 真是個有感的功能呀。\n實驗環境 golang\n $ go version go version go1.16 darwin/amd64 docker\n $ docker version Client: Docker Engine - Community Cloud integration: 1.0.7 Version: 20.10.2 API version: 1.41 Go version: go1.13.15 Git commit: 2291f61 Built: Mon Dec 28 16:12:42 2020 OS/Arch: darwin/amd64 Context: default Experimental: true Server: Docker Engine - Community Engine: Version: 20.10.2 API version: 1.41 (minimum version 1.12) Go version: go1.13.15 Git commit: 8891c58 Built: Mon Dec 28 16:15:28 2020 OS/Arch: linux/amd64 Experimental: false containerd: Version: 1.4.3 GitCommit: 269548fa27e0089a8b8278fc4fc781d7f65a939b runc: Version: 1.0.0-rc92 GitCommit: ff819c7e9184c13b7c2607fe6c30ae19403a7aff docker-init: Version: 0.19.0 GitCommit: de40ad0 Kubernetes: Version: v1.16.15-gke.7800 StackAPI: Unknown 此為範例專案最終完成版，並且可以透過 git 記錄看到版本一和版本二的內容。 sha256sum\n5321e3a3d67195f7c44f7c1e76ca229717fcd49ebb3359528038745670f68aba example.tar.gz Reference  https://docs.docker.com/develop/develop-images/multistage-build/ 打造最小 Go Docker Image https://blog.alexellis.io/mutli-stage-docker-builds/ https://www.docker.com/blog/tag/go-env-series/ https://github.com/moby/buildkit/blob/master/frontend/dockerfile/docs/syntax.md https://www.ctl.io/developers/blog/post/more-docker-image-cache-tips/ How to write excellent Dockerfiles  ","wordCount":"491","inLanguage":"zh","datePublished":"2021-03-01T21:57:33Z","dateModified":"2021-03-01T21:57:33Z","author":{"@type":"Person","name":"amikai"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://amikai.github.io/2021/03/01/docker-multi-stage-build/"},"publisher":{"@type":"Organization","name":"no code no pain","logo":{"@type":"ImageObject","url":"https://amikai.github.io/favicon.ico"}}}</script>
</head>
<body id=top>
<script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script>
<noscript>
<style type=text/css>#theme-toggle,.top-link{display:none}</style>
<style>@media(prefers-color-scheme:dark){:root{--theme:#1d1e20;--entry:#2e2e33;--primary:rgba(255, 255, 255, 0.84);--secondary:rgba(255, 255, 255, 0.56);--tertiary:rgba(255, 255, 255, 0.16);--content:rgba(255, 255, 255, 0.74);--hljs-bg:#2e2e33;--code-bg:#37383e;--border:#333}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style>
</noscript>
<header class=header>
<nav class=nav>
<div class=logo>
<a href=https://amikai.github.io accesskey=h title="no code no pain (Alt + H)">no code no pain</a>
<span class=logo-switches>
<button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg>
</button>
<ul class=lang-switch><li>|</li>
<li>
<a href=https://amikai.github.io/en/ title=English aria-label=English>English</a>
</li>
</ul>
</span>
</div>
<ul id=menu onscroll=menu_on_scroll()>
<li>
<a href=https://amikai.github.io/archives title=Archive>
<span>Archive</span>
</a>
</li>
<li>
<a href=https://amikai.github.io/categories/ title=Categories>
<span>Categories</span>
</a>
</li>
<li>
<a href=https://amikai.github.io/tags/ title=Tags>
<span>Tags</span>
</a>
</li></ul>
</nav>
</header>
<main class=main>
<article class=post-single>
<header class=post-header>
<h1 class=post-title>
Dockerfile - Multi-stage build 筆記
</h1>
<div class=post-meta>
March 1, 2021&nbsp;·&nbsp;amikai
</div>
</header>
<div class=post-content>
<p>在專案開發時，通常會執行代碼檢查、單元測試、編譯、執行等等。</p>
<p>在 docker 還沒出現之前，這些流程都是在本機上跑 (版本 0)，因為環境的不一致可能導致不同主機執行結果不相同。將這些流程步驟撰寫成 dockerfile 直接在容器裡執行就可以解決上述問題 (版本 1)，但也衍伸出了新的問題。為了執行代碼檢查和編譯，下載了許多套件或是相依工具，造成映像檔肥大，很多套件或是相依工具在部署時是不需要的。</p>
<p>如果把這些步驟拆成兩個階段思考 (版本 2)</p>
<ul>
<li>開發整合階段：代碼檢查、單元測試、編譯等等使用。</li>
<li>部署階段：跑起執行檔，將此兩階段寫成兩個 dockerfile，並且建構出兩個映像檔，只要拿後者映像檔去部署即可。
版本 2 成功解決了部署映像檔大小的問題，可是在必須維護兩個 dockerfile 還有中間流程所需的 script，Docker 17.05 所推出的 Multi-stage build 正好能解決此問題 (版本 3)。</li>
</ul>
<p>以下則是 版本 0 進化到 版本 3 的過程及解釋。</p>
<h1 id=範例-go-專案版本-0沒使用-docker>範例 go 專案，版本 0：沒使用 docker<a hidden class=anchor aria-hidden=true href=#範例-go-專案版本-0沒使用-docker>#</a></h1>
<p>此專案使用 gin 實作 http server 只要對它請求 <code>GET /ping</code> ，則會回覆 pong，
以下是專案結構：</p>
<pre><code>&gt; tree example
example
├── go.mod
├── go.sum
├── main.go
└── main_test.go 
</code></pre><p>在完成程式碼撰寫之後，執行以下步驟</p>
<ol>
<li>使用 go vet 檢查</li>
<li>使用 staticcheck 檢查</li>
<li>跑完測試</li>
<li>編譯專案</li>
<li>執行</li>
</ol>
<pre><code class="language-=" data-lang="=">$ go vet ./...
$ staticcheck ./...
$ go test ./...
$ go build -o ./server
$ ./server
</code></pre><h1 id=dockerfile-版本一-全部都塞在一個映像檔>Dockerfile 版本一： 全部都塞在一個映像檔<a hidden class=anchor aria-hidden=true href=#dockerfile-版本一-全部都塞在一個映像檔>#</a></h1>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-dockerfile data-lang=dockerfile><span style=color:#66d9ef>FROM</span><span style=color:#e6db74> golang:1.16.0-alpine3.13</span><span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span><span style=color:#75715e># go module</span><span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>ENV</span> GO111MODULE<span style=color:#f92672>=</span>on CGO_ENABLED<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>

<span style=color:#75715e># install staticcheck binary</span><span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>RUN</span> go install honnef.co/go/tools/cmd/staticcheck@v0.1.2<span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>WORKDIR</span><span style=color:#e6db74> /workspace/example</span><span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span><span style=color:#75715e># download dependency</span><span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>COPY</span> go.mod go.sum .<span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>RUN</span>  go mod download<span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span><span style=color:#75715e># Copy source code</span><span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>COPY</span> . ./<span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>RUN</span> go vet ./... <span style=color:#f92672>&amp;&amp;</span> staticcheck ./... <span style=color:#f92672>&amp;&amp;</span> go test ./... <span style=color:#f92672>&amp;&amp;</span> go build -o /bin/server<span style=color:#960050;background-color:#1e0010>
</span></code></pre></div><p>把映像檔做出來</p>
<pre><code>$ docker image build -t amikai/example:v1  .
</code></pre><p>為了要對此專案進行代碼檢查和編譯，必須將相關工具以及依賴下載好，而這些依賴及工具都會佔用到空間，觀察 container 裡 <code>/go</code> (go 相關依賴) 就佔了 328.7 MB (使用 <code>du -sh /go</code> 觀察)，而整個映像檔是 687 MB，映像檔大小還有相當大的改善空間。</p>
<h1 id=dockerfile-版本二拆成兩個階段思考>Dockerfile 版本二：拆成兩個階段思考<a hidden class=anchor aria-hidden=true href=#dockerfile-版本二拆成兩個階段思考>#</a></h1>
<p>把版本一的 dockfile 拆成兩個階段思考：</p>
<ul>
<li>從建構的階段來想：為了確保每個人在代碼檢查以及編譯的環境是統一的，減少環境不同所造成的問題。</li>
<li>從部署的階段來想：最後只要留下需要編譯後所產生的執行檔，其他相關的依賴和工具都是不必要的，編譯完後放在那只是佔位置。</li>
</ul>
<p>把這兩個階段的事情，拆成兩個映像檔：</p>
<ul>
<li>建構階段 (Dockerfile)：此階段是對原始碼進行檢查及編譯等等，不太需要考慮映像檔大小，反正不會拿去部署。</li>
<li>部署階段 (Dockerfile.build)： 此在意的是映像檔大小，所以留下編譯後的執行檔即可。</li>
</ul>
<p>具體的做法就是先做出一個 <code>Dockerfile.build</code> 去 build 出執行檔，把此執行檔取出，再寫一個 <code>Dockerfile</code> 將此執行檔放入，開始執行。在使用一個 <code>build.sh</code> 將上述事情自動化。</p>
<p>Dockerfile.build</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-docker data-lang=docker><span style=color:#66d9ef>FROM</span><span style=color:#e6db74> golang:1.16.0-alpine3.13</span><span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span><span style=color:#75715e># go module</span><span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>ENV</span> GO111MODULE<span style=color:#f92672>=</span>on CGO_ENABLED<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>

<span style=color:#75715e># install staticcheck binary</span><span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>RUN</span> go install honnef.co/go/tools/cmd/staticcheck@v0.1.2<span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>WORKDIR</span><span style=color:#e6db74> /workspace/example</span><span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span><span style=color:#75715e># download dependency</span><span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>COPY</span> go.mod go.sum .<span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>RUN</span>  go mod download<span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span><span style=color:#75715e># Copy source code</span><span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>COPY</span> . ./<span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>RUN</span> go vet ./... <span style=color:#f92672>&amp;&amp;</span> staticcheck ./... <span style=color:#f92672>&amp;&amp;</span> go test ./... <span style=color:#f92672>&amp;&amp;</span> go build -o /bin/server<span style=color:#960050;background-color:#1e0010>
</span></code></pre></div><p>Dockerfile</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-dockerfile data-lang=dockerfile><span style=color:#66d9ef>FROM</span><span style=color:#e6db74> alpine:latest</span><span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>WORKDIR</span><span style=color:#e6db74> /root/</span><span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>COPY</span> server .<span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>ENTRYPOINT</span> [<span style=color:#e6db74>&#34;./server&#34;</span>]<span style=color:#960050;background-color:#1e0010>
</span></code></pre></div><p>build.sh</p>
<pre><code class="language-shell=#!/bin/sh" data-lang="shell=#!/bin/sh">#!/bin/sh
echo Building amikai/example:build

docker build -t amikai/example:build . -f Dockerfile.build
docker container create --name extract amikai/example:build 
docker container cp extract:/bin/server ./server
docker container rm -f extract

echo Building amikai/example:v2
docker image build --no-cache -t amikai/example:v2  .
</code></pre><p>執行 build.sh 將 example:v2 的映像檔做出來，這個映像檔大小是 15 MB，已經和版本一的 687 MB 有很大的進步空間。</p>
<p>雖然最終產出的映像檔大小有極大的改善，但為了這個映像檔，必須維護三個檔案，在微服務的世界裡，如果一個容器裝一個服務，就必須維護 服務數量 * 3 的檔案。</p>
<p>而且是兩個映像檔分別都會佔用到硬碟空間，也就是說雖然拿來部署的映像檔改善了大小，但總體佔用的硬碟空間和版本一是幾乎一樣的。</p>
<h1 id=dockerfile-版本三-multi-stage-builds>Dockerfile 版本三： multi-stage builds<a hidden class=anchor aria-hidden=true href=#dockerfile-版本三-multi-stage-builds>#</a></h1>
<p>docker 在 17.05 提出 multi-stage builds，整個 dockerfile 可以分割成好幾個 stage，每個 stage 由 <code>FROM</code> 作為開始，也就是說 <code>FROM</code> 除了選擇基底映像檔之外，還有新 stage 起始的意義。</p>
<p>multi-stage 功能讓我們可以將此 stage 所需要的檔案，複製到下個 stage 做其他事，則最終做出來的映像檔只會留下所需的檔案。</p>
<p>版本三的 dockerfile 如下，有兩個 stage:</p>
<ol>
<li>builder stage: 以 golang 為基底的映像檔，用來做原始碼檢查、測試，並且編譯出執行檔</li>
<li>release stage: 將 builder stage 的執行檔複製過來，並且執行</li>
</ol>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-dockerfile data-lang=dockerfile><span style=color:#66d9ef>FROM</span><span style=color:#e6db74> golang:1.16.0-alpine3.13 AS builder</span><span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>WORKDIR</span><span style=color:#e6db74> /workspace/example</span><span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>ENV</span> GO111MODULE<span style=color:#f92672>=</span>on CGO_ENABLED<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>
<span style=color:#75715e># download dependency</span><span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>COPY</span> go.mod go.sum .<span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>RUN</span>  go mod download<span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>RUN</span> go install honnef.co/go/tools/cmd/staticcheck@v0.1.2<span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>COPY</span> . .<span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>RUN</span> go vet ./... <span style=color:#f92672>&amp;&amp;</span> staticcheck ./... <span style=color:#f92672>&amp;&amp;</span> go test ./... <span style=color:#f92672>&amp;&amp;</span> go build -o /bin/server<span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>FROM</span><span style=color:#e6db74> alpine:latest AS release</span><span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span><span style=color:#75715e># Copy from builder</span><span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>COPY</span> --from<span style=color:#f92672>=</span>builder /bin/server /bin/server<span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>ENTRYPOINT</span> [<span style=color:#e6db74>&#34;./bin/server&#34;</span>]<span style=color:#960050;background-color:#1e0010>
</span></code></pre></div><p>把映像檔做出來</p>
<pre><code>$ docker image build -t amikai/example:v3  .
</code></pre><p>版本三的映像檔大小為 15 MB，解決了版本二不需要維護三個檔案也解決了版本一產出肥大映像檔的痛點。multi-stage builds 真是個有感的功能呀。</p>
<h1 id=實驗環境>實驗環境<a hidden class=anchor aria-hidden=true href=#實驗環境>#</a></h1>
<p>golang</p>
<pre><code> $ go version
go version go1.16 darwin/amd64
</code></pre><p>docker</p>
<pre><code> $ docker version
Client: Docker Engine - Community
 Cloud integration: 1.0.7
 Version:           20.10.2
 API version:       1.41
 Go version:        go1.13.15
 Git commit:        2291f61
 Built:             Mon Dec 28 16:12:42 2020
 OS/Arch:           darwin/amd64
 Context:           default
 Experimental:      true

Server: Docker Engine - Community
 Engine:
  Version:          20.10.2
  API version:      1.41 (minimum version 1.12)
  Go version:       go1.13.15
  Git commit:       8891c58
  Built:            Mon Dec 28 16:15:28 2020
  OS/Arch:          linux/amd64
  Experimental:     false
 containerd:
  Version:          1.4.3
  GitCommit:        269548fa27e0089a8b8278fc4fc781d7f65a939b
 runc:
  Version:          1.0.0-rc92
  GitCommit:        ff819c7e9184c13b7c2607fe6c30ae19403a7aff
 docker-init:
  Version:          0.19.0
  GitCommit:        de40ad0
 Kubernetes:
  Version:          v1.16.15-gke.7800
  StackAPI:         Unknown
</code></pre><p>此為範例專案最終完成版，並且可以透過 git 記錄看到版本一和版本二的內容。
<img loading=lazy src=example.tar.gz alt>
</p>
<p>sha256sum</p>
<pre><code>5321e3a3d67195f7c44f7c1e76ca229717fcd49ebb3359528038745670f68aba  example.tar.gz
</code></pre><h1 id=reference>Reference<a hidden class=anchor aria-hidden=true href=#reference>#</a></h1>
<ul>
<li><a href=https://docs.docker.com/develop/develop-images/multistage-build/>https://docs.docker.com/develop/develop-images/multistage-build/</a></li>
<li><a href=https://tachingchen.com/tw/blog/building-minimal-docker-image-for-go-applications/>打造最小 Go Docker Image</a></li>
<li><a href=https://blog.alexellis.io/mutli-stage-docker-builds/>https://blog.alexellis.io/mutli-stage-docker-builds/</a></li>
<li><a href=https://www.docker.com/blog/tag/go-env-series/>https://www.docker.com/blog/tag/go-env-series/</a></li>
<li><a href=https://github.com/moby/buildkit/blob/master/frontend/dockerfile/docs/syntax.md>https://github.com/moby/buildkit/blob/master/frontend/dockerfile/docs/syntax.md</a></li>
<li><a href=https://www.ctl.io/developers/blog/post/more-docker-image-cache-tips/>https://www.ctl.io/developers/blog/post/more-docker-image-cache-tips/</a></li>
<li><a href=https://rock-it.pl/how-to-write-excellent-dockerfiles/>How to write excellent Dockerfiles</a></li>
</ul>
</div>
<footer class=post-footer>
<ul class=post-tags>
<li><a href=https://amikai.github.io/tags/docker/>docker</a></li>
</ul>
</footer>
<script src=https://utteranc.es/client.js repo=amikai/my_hugo_blog_utterances issue-term=title label=amikai/my_hugo_blog_utterances theme=github-light crossorigin=anonymous async></script>
</article>
</main><footer class=footer>
<span>&copy; 2021 <a href=https://amikai.github.io>no code no pain</a></span>
<span>&#183;</span>
<span>Powered by <a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a></span>
<span>&#183;</span>
<span>Theme <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span>
</footer>
<a href=#top aria-label="go to top" title="Go to Top (Alt + G)">
<button class=top-link id=top-link type=button accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</button>
</a>
<script defer src=/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5+kdJvBz5iKbt6B5PJI=" onload=hljs.initHighlightingOnLoad()></script>
<script>window.onload=function(){localStorage.getItem("menu-scroll-position")&&(document.getElementById('menu').scrollLeft=localStorage.getItem("menu-scroll-position"))};function menu_on_scroll(){localStorage.setItem("menu-scroll-position",document.getElementById('menu').scrollLeft)}document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script>
<script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script>
<script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script>
</body>
</html>