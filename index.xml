<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>no code no pain</title><link>https://amikai.github.io/</link><description>Recent content on no code no pain</description><generator>Hugo -- gohugo.io</generator><language>zh-tw</language><lastBuildDate>Sun, 23 May 2021 05:51:41 +0000</lastBuildDate><atom:link href="https://amikai.github.io/index.xml" rel="self" type="application/rss+xml"/><item><title>好用的 vim virtualedit 選項</title><link>https://amikai.github.io/2021/05/23/vim-virtualedit/</link><pubDate>Sun, 23 May 2021 05:51:41 +0000</pubDate><guid>https://amikai.github.io/2021/05/23/vim-virtualedit/</guid><description>使用 ctrl+v 把一個圖片中的英文字母區塊刪掉會像以下這樣 顯然是不如預期 set virtualedit=block 設定了此選項之後 什麼是 virutaledit 在 vim 裡預設行為：游標無法放在沒有字元的地方，也就是 set virtualedit=。 所以 set virtualedit=block 指的是在 block mode 裡 (也就是 ctrl + v) 可以將游標移到沒有字元的位置
Reference :help virtualedit</description></item><item><title>Dockerfile - Multi-stage build 筆記</title><link>https://amikai.github.io/2021/03/01/docker-multi-stage-build/</link><pubDate>Mon, 01 Mar 2021 21:57:33 +0000</pubDate><guid>https://amikai.github.io/2021/03/01/docker-multi-stage-build/</guid><description>在專案開發時，通常會執行代碼檢查、單元測試、編譯、執行等等。
在 docker 還沒出現之前，這些流程都是在本機上跑 (版本 0)，因為環境的不一致可能導致不同主機執行結果不相同。將這些流程步驟撰寫成 dockerfile 直接在容器裡執行就可以解決上述問題 (版本 1)，但也衍伸出了新的問題。為了執行代碼檢查和編譯，下載了許多套件或是相依工具，造成映像檔肥大，很多套件或是相依工具在部署時是不需要的。
如果把這些步驟拆成兩個階段思考 (版本 2)
開發整合階段：代碼檢查、單元測試、編譯等等使用。 部署階段：跑起執行檔，將此兩階段寫成兩個 dockerfile，並且建構出兩個映像檔，只要拿後者映像檔去部署即可。 版本 2 成功解決了部署映像檔大小的問題，可是在必須維護兩個 dockerfile 還有中間流程所需的 script，Docker 17.05 所推出的 Multi-stage build 正好能解決此問題 (版本 3)。 以下則是 版本 0 進化到 版本 3 的過程及解釋。
範例 go 專案，版本 0：沒使用 docker 此專案使用 gin 實作 http server 只要對它請求 GET /ping ，則會回覆 pong， 以下是專案結構：
&amp;gt; tree example example ├── go.mod ├── go.sum ├── main.go └── main_test.go 在完成程式碼撰寫之後，執行以下步驟
使用 go vet 檢查 使用 staticcheck 檢查 跑完測試 編譯專案 執行 $ go vet .</description></item><item><title>在 (neo)vim 裡 C 語言程式碼導覽技巧</title><link>https://amikai.github.io/2020/11/28/vim-c-env-move/</link><pubDate>Sat, 28 Nov 2020 21:50:57 +0000</pubDate><guid>https://amikai.github.io/2020/11/28/vim-c-env-move/</guid><description>現代的專案開發，很少在從無到有打造，大部分都是基於現有的程式之上繼續開發或維護，進入專案之後，通常第一件事就是大量閱讀程式碼理清專案的整個脈絡，才開始著手寫 code，所以好的程式碼導覽技巧將會帶你上天堂。
我將大部分的程式碼導覽情境大致拆成了三種情況：
基本的跳轉： #if #endif 中間的程式碼太長，想要跳轉到成對的 #if #endif cursor 在 {&amp;hellip;} block 裡， 這個 block 又臭又長，想快速跳轉 block 的開頭和結尾 註解長篇大論，想快速跳到註解的開頭或結尾 尋找專案下檔案 (可透過設定 path option 解決) 跳轉到標頭檔 跳轉到指定檔案 使用 source code tagging system 快速挑轉到 function 定義及特定 symbol 等等： 專案相當大的時候，source code tagging system 相當好用，可以快速找到定位，也不會花掉太多的資源，比起 LSP 的跳轉定義，是較輕量的選擇。 本篇依據上述三種情境，一一講述。
常用跳轉操作 %
跳到成對的括號 如果註解是 /*...*/，跳到成對的註解符號 在成對的 #if, #ifdef, #else, #elif, #endif 之中跳轉，這相當重要，如果 code 很長, if else macro 又是巢狀的，這招可以讓你少迷路好幾次 [{ ]}</description></item><item><title>聊聊你在 vim 常用的移動方式</title><link>https://amikai.github.io/2020/10/03/vim-commonly-used-motion/</link><pubDate>Sat, 03 Oct 2020 10:53:36 +0000</pubDate><guid>https://amikai.github.io/2020/10/03/vim-commonly-used-motion/</guid><description>看下圖，如果想將 &amp;lt;expr&amp;gt; 改成 &amp;lt;leader&amp;gt; 你會怎麼做呢? 通常我看過的幾種方式如下：
使用 j 向下到 97 行，在使用 l 到 target 並且開始編輯，這也是最糟的 target 的行數看起來離 window 中央行很近， 使用 M 跳到 window 中央行，再使用 h j k l 到 target 使用 :set number 列出行號， 按下 97G 到達 97 行， fe ; ; ; 註: f{char} 找到此行的下一個字母、 ; 為重複上一個 f 命令 使用 / 搜尋 expr，在使用 n n n n 到 target 使用 set mouse=n，用滑鼠點 target Easymotion easymotion 是解決此情境最好的方案之一，它提供了另一種搜尋方式，在搜尋目標之後，會將可能位置的抽換成其他字母，並高亮這些字母，再按下這些字母就可以跳到此位置 (之後簡稱為 label and jump 功能)。 easymotion 的設計就是加強內建的移動指令，只是跳轉到目標的方式變了，所以不需要擔心不會用。</description></item><item><title>vim 高亮 yank 區域</title><link>https://amikai.github.io/2020/09/29/vim-tips-highlight-yank-region/</link><pubDate>Tue, 29 Sep 2020 21:09:01 +0000</pubDate><guid>https://amikai.github.io/2020/09/29/vim-tips-highlight-yank-region/</guid><description>y 是在 vim 裡最常使用的使用的 operator 之一，使用 y operator 將會執行 yank 動作，但它無法像 c (change) 和 d (delete) operator 使用之後馬上就知道對文件編輯了什麼。yank 動作是沒有反饋的，按了 yiw 複製 word 之後，你也無法確定是不是按對了，還要使用 :reg 檢視，頗麻煩的。
解決方案：在使用 yank operator 之後，高亮複製區域短暫的時間，就能確認複製的區域有沒有誤。以下圖例為，在 23 行按下 yy, 在 24 行的 return 上按下 yiw
在 neovim 0.5 裡達到這件事相當簡單，把以下加近
autocmd TextYankPost * silent! lua vim.highlight.on_yank{higroup=&amp;#34;IncSearch&amp;#34;, timeout=300}如果是使用 vim 也可以用 vim-highlightedyank 套件達成
Plug &amp;#39;machakann/vim-highlightedyank&amp;#39;let g:highlightedyank_highlight_duration = 300if !exists(&amp;#39;##TextYankPost&amp;#39;) map y &amp;lt;Plug&amp;gt;(highlightedyank)endifReference https://github.com/neovim/neovim/pull/12279 neovim :help lua-highlight</description></item><item><title>你應該擴充的 text object</title><link>https://amikai.github.io/2020/09/22/vim-text-object/</link><pubDate>Tue, 22 Sep 2020 19:03:52 +0000</pubDate><guid>https://amikai.github.io/2020/09/22/vim-text-object/</guid><description>vim 高效率編輯的背後，operator, motion, text object 的配合功不可沒。
operator 是編輯的動作， text object 就是文字區塊，motion 是跳轉到文件點，透過三者的按鍵配合，就能達到所想及所得的編輯方式。
如果你有看過別人使用 vim ，通常會有這種想法：怎麼隨便按幾個鍵就刪這裡刪那裡複製這裡複製那裡，速度快到看不懂在幹嘛，而且還不會出錯，因為只要想好要做什麼，按鍵按下去就對了，這也是為什麼會高效率。說了一堆，反正就是 耍潮必備。
本篇將會提到:
operator, text object, motion 的配合用法 內建 text object 的不足之處 擴充 text object 的 plugin 淺談 nvim-treesitter Operator &amp;amp; text object Vim 定義了多個 operator 最常用的就是:
d delete (刪除) c change (更改) y yank (複製) operator 沒有配合 text object 或是 motion 是沒有意義的，想像一下使用了 d 刪除，但是沒告訴它要刪除什麼，就像有了鐵鎚不知道要打什麼。所以需要給 operator 一個目標，讓它要對誰做什麼。這個誰就有兩種，motion 和 text object。
motion：其實就是跳轉指令，像是常用的 G,gg, w, f{char} &amp;hellip; 等都可以配合 operator。基本使用方法為 {operator}{motion}，語意就是做這個 operator 動作到 motion 所到的地方</description></item><item><title>誰說不能在 vim 裡編譯，從 :make 到 :Make</title><link>https://amikai.github.io/2020/09/10/vim-make/</link><pubDate>Thu, 10 Sep 2020 00:21:31 +0000</pubDate><guid>https://amikai.github.io/2020/09/10/vim-make/</guid><description>前言 回想一下，上一次使用 vim 寫 code 到一個段落要編譯時，你是怎麼做的。
我看到大多數人的方式，就是將 terminal 切成兩塊，一塊寫 code，一塊編譯，若編譯有錯誤，再移動到寫 code 區塊更改。 如果使用此方法，當專案有規模時，編譯錯誤一百條，看了編譯錯誤在哪之後，再將編譯錯誤的位置，從專案裡找出來，反覆來回 100 次，直到修正完畢。 本文以 C 語言專案為例 (當然不是只有 C 語言才能這樣子幹，可看 Q&amp;amp;A)，聊聊強大的 vim 在這種情境下有什麼好的解決方案。 強大的 :make 基本款 此次範例就拿 neovim 來編譯好了，根據官方文件要這樣編譯 make CMAKE_BUILD_TYPE=Release，所以在我在 vim 裡這樣編 :make CMAKE_BUILD_TYPE=Release
看起來噴了一點錯誤，案了 enter 似乎之後什麼事都沒發生，回到平常。 用 :cl 指令，喔幹!不是一點錯誤，是一堆錯誤，沒列出來根本不知道。 重點來了!! 可以使用 :cn (:cnext) 跳到下一個錯誤位置，:cp (:cprevious) 跳轉到上一個錯誤位置，就不需要自己手動一個一個錯誤找出來。 看上圖，可以觀察到，每一條錯誤前面都有一個數字，如果想要跳到特定錯誤去修那就使用 :cc [number]，跳轉到第一個錯誤就用 :cc 12，跳轉到第三個錯誤就用 :cc 19。
火力展示: 總結一下指令:
:make: 執行 makefile :cl: 列出所有錯誤 :cn: 跳到下個錯誤 :cp: 跳到上個錯誤 :cc [number]: 跳轉到特定錯誤 如虎添翼的 quickfix-window 編譯完之後，除了用 :cl 查看，另一種方式就是用 :copen，打下此指令之後，將會彈出 quickfix-window，列出的錯誤其實就是 :clist 的詳細版本， quickfix-window 只是提供了一種查找的方式。 移轉到 quickfix-window 後，移動到想要查看的錯誤，案 enter 即可跳轉到該錯誤位置，當然也能配合 :cn, :cp, :cc [number]，quickfix-window 會配合這些指令連動顯示目前位置。</description></item><item><title>聊聊 vim mark 使用情境 - code 參照</title><link>https://amikai.github.io/2020/09/07/vim-mark-tips/</link><pubDate>Mon, 07 Sep 2020 15:03:01 +0000</pubDate><guid>https://amikai.github.io/2020/09/07/vim-mark-tips/</guid><description>寫程式的時候常常遇到一種情況，假設你是團隊的新人，需要常常參照別人的程式，看看團隊的 coding style 等等，可能需要參照 A file 的第 10 行，B file 第 8 行，C file 第 999 行。
另一種情境則是在寫測試的時候會和實作交互參照，而測試程式往往和實作程式會拆開不同的檔案，所以就必須要一直跳轉。
使用 split 的方式縱然是一個不錯的方式，但是如果要參照的點大於三個，就將螢幕切成三份，那工程師就相當痛苦了，不是每個人都用這種電腦螢幕啊。這種 split 的方式還有另一個缺點：如果手殘將檔案關掉，就得重找。 Mark vim 的 mark 取名或許源自於 bookmark (書籤) 這個字，書籤的用意在於能快速找回你上次看的那一頁，而 vim mark 的用意也是如此：能快速找回你剛剛在看 code 的地方。
vim 的 mark 分為三種：
Local mark a-z： 每一個 file 裡皆有自己的 local mark，也就是說檔案 A 可以有 mark a, 檔案 B 裡也可以有自己的 mark a Global mark A-Z： 此種 mark 是全域的，也就是說在檔案 A 裡所看到的 mark A 和 B 檔案 B 裡的 mark A 是一樣的 Special mark：其他神奇的 mark，不在此文章討論範圍 mark 的基本使用：</description></item><item><title>Golang 開發環境 - 使用 neovim</title><link>https://amikai.github.io/2020/09/03/go_neovim_env/</link><pubDate>Thu, 03 Sep 2020 10:48:54 +0000</pubDate><guid>https://amikai.github.io/2020/09/03/go_neovim_env/</guid><description>你確定要用 neovim 開發 golang? 現在是 vscode 稱霸天下的時代，理所當然的 (neo)vim 也常常被拿來 vscode 比較，vscode 內建整合了 git、debugger、自動補全引擎、terminal、extension manager，另外 Golang 在 vscode 上的 extension 支援相當良好: 包括跳轉到定義 (go to definition)、重新命名 (rename)、跳轉到型態定義 (go to type definition)⋯⋯ 一堆細節功能，近期由於 google golang team 接手 go 語言的 vscode extension，相信使用 vscode 開發是不錯的選擇。
(neo)vim 當然也能達到 vscode 的類似功能，但是必須花時間設定調教，在 vscode 問世之前我會推薦 (Neo)vim 給我的朋友，vscode 問世之後我就開始推薦 vscode。
本文給那些本來就在 (neo)vim 裡打滾的人，但對 go 語言設定不熟的人， 如果你是一張白紙，而且沒有被虐的癖好，我建議選擇 vscode，可以用較少的時間進入到寫程式的環節，而不是一直在花時間在設定，這篇文你也沒必要看下去。
預備動作 Must have
你應該先安裝好 neovim nightly 版本，brew install neovim --HEAD 你應該要知道怎麼使用 vim-plug，至少要知道 :PlugInstall 你應該先把 go 語言環境安裝好 Nice to have</description></item><item><title>Golang 78 語法篇 - method set</title><link>https://amikai.github.io/2020/07/07/golang78syntax2/</link><pubDate>Tue, 07 Jul 2020 13:42:50 +0000</pubDate><guid>https://amikai.github.io/2020/07/07/golang78syntax2/</guid><description>method set, interface, auto deference or reference 當這些語法綜合再一起使用時，很容易混淆，甚至寫出 bug code，這章我們就透過題目探討一下 method set 常常被大家誤會的地方。
Golang 78 語法篇 - interface % Line 50 用到的概念就在這篇。
題目 請問以下程式輸出結果為何
type Employee struct {} func (e Employee) DoWork() { fmt.Println(&amp;#34;do work&amp;#34;) } func main() { (&amp;amp;Employee{}).DoWork() } 答案只有兩種方向: 1. 無法編譯 2. 印出 do work
這個程式可以編譯，並且還印出 do work 但是為什麼呢？
Method set 在 receiver argument 和 receiver parameter 不一樣的情況下，直覺反應就是 implicit dereference 和 implicit reference 在背後會幫忙，但是這個寫法 (struct literal) 是不會有此情況的。</description></item><item><title>Golang 78 語法篇 - interface</title><link>https://amikai.github.io/2020/07/03/golang78syntax/</link><pubDate>Fri, 03 Jul 2020 10:59:36 +0000</pubDate><guid>https://amikai.github.io/2020/07/03/golang78syntax/</guid><description>Interface 可以說是 golang 的精髓之一。golang interface 特殊的語法以及概念也是工程師常常犯錯的地方。此題只是用來釐清自己的概念。
題目 請問以下程式輸出結果為何
package main import &amp;#34;fmt&amp;#34; type S struct{ val int } func (s S) F() {} type IF interface { F() } func InitType() S { var s S return s } func InitPointer() *S { var s *S return s } func InitEfaceType() interface{} { var s S return s } func InitEfacePointer() interface{} { var s *S return s } func InitIfaceType() IF { var s S return s } func InitIfacePointer() IF { var s *S return s } func main() { // fmt.</description></item><item><title>Hello 世界</title><link>https://amikai.github.io/2000/07/22/hello-world/</link><pubDate>Sat, 22 Jul 2000 15:16:51 +0800</pubDate><guid>https://amikai.github.io/2000/07/22/hello-world/</guid><description>Hello 世界</description></item></channel></rss>